<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Baby World v3</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a0f;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: default;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  #face {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 180px; height: 180px;
    pointer-events: none;
    z-index: 10;
    animation: breathe 4s ease-in-out infinite;
  }
  @keyframes breathe {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
  }
  .eye-lid {
    transform-origin: center;
    animation: blink 4s ease-in-out infinite;
  }
  .eye-lid-right {
    animation-delay: 0.1s;
  }
  @keyframes blink {
    0%, 90%, 100% { transform: scaleY(1); }
    95% { transform: scaleY(0.05); }
  }
</style>
</head>
<body>

<svg id="face" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <circle cx="100" cy="100" r="90" fill="#fff" stroke="#e0e0e0" stroke-width="2"/>
  <g class="eye-lid">
    <ellipse cx="70" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
    <ellipse cx="74" cy="78" rx="6" ry="7" fill="#fff"/>
  </g>
  <g class="eye-lid eye-lid-right">
    <ellipse cx="130" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
    <ellipse cx="134" cy="78" rx="6" ry="7" fill="#fff"/>
  </g>
  <ellipse cx="50" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <ellipse cx="150" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <path d="M 70 120 Q 100 150 130 120" stroke="#1a1a2e" stroke-width="4" fill="none" stroke-linecap="round"/>
</svg>

<canvas id="canvas"></canvas>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // --- Resize ---
  function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    initStars(); // re-distribute stars on resize
  }
  window.addEventListener('resize', resize);

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  // ==============================================
  // V3 IMPROVEMENT 1: Twinkling Star Field
  // ==============================================
  const stars = [];
  const STAR_COUNT = 80;

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({
        x: Math.random() * W(),
        y: Math.random() * H(),
        baseSize: 0.5 + Math.random() * 2,
        twinkleSpeed: 0.001 + Math.random() * 0.003,
        twinklePhase: Math.random() * Math.PI * 2,
        baseAlpha: 0.2 + Math.random() * 0.5,
      });
    }
  }

  function drawStars(time) {
    for (const star of stars) {
      const twinkle = Math.sin(time * star.twinkleSpeed + star.twinklePhase);
      const alpha = star.baseAlpha * (0.3 + 0.7 * (twinkle * 0.5 + 0.5));
      const size = star.baseSize * (0.8 + 0.4 * (twinkle * 0.5 + 0.5));

      ctx.save();
      ctx.globalAlpha = alpha;

      // Soft glow
      const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, size * 3);
      gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.4, 'rgba(200,210,255,0.3)');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(star.x, star.y, size * 3, 0, Math.PI * 2);
      ctx.fill();

      // Bright core
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }
  }

  // ==============================================
  // V3 IMPROVEMENT 3: Device Accelerometer / Gravity
  // ==============================================
  let gravityX = 0;
  let gravityY = 0;
  let hasGyro = false;

  // Request permission on iOS 13+
  function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
      DeviceMotionEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
            enableMotion();
          }
        }).catch(() => {});
    } else {
      enableMotion();
    }
  }

  function enableMotion() {
    window.addEventListener('deviceorientation', (e) => {
      hasGyro = true;
      // beta = front-back tilt (-180 to 180), gamma = left-right tilt (-90 to 90)
      const beta = e.beta || 0;   // front/back
      const gamma = e.gamma || 0; // left/right

      // Normalize to a gentle force (-1 to 1 range, clamped)
      gravityX = Math.max(-1, Math.min(1, gamma / 30));
      gravityY = Math.max(-1, Math.min(1, (beta - 45) / 30)); // 45 = natural holding angle
    });
  }

  // Try to enable on load (works on Android, desktop)
  enableMotion();

  // ==============================================
  // Color Evolution (from v2)
  // ==============================================
  const colorPhases = [
    ['#ffffff', '#e0e0e0', '#c0c0c0', '#d0d0d0', '#f5f5f5'],
    ['#ffffff', '#e0e0e0', '#ff4444', '#ff6b6b', '#ffaaaa'],
    ['#ffffff', '#ff4444', '#4488ff', '#66aaff', '#aaccff'],
    ['#ff4444', '#ff6b6b', '#ffdd44', '#ffee77', '#ffaa33'],
    ['#4488ff', '#66aaff', '#44dd88', '#77eebb', '#88ddff'],
    ['#ff4444', '#ffdd44', '#44dd88', '#4488ff', '#cc66ff'],
  ];

  const PHASE_DURATION = 45000;
  let colorPhaseStart = performance.now();

  function lerpColor(a, b, t) {
    const ah = parseInt(a.slice(1), 16);
    const bh = parseInt(b.slice(1), 16);
    const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    const rr = Math.round(ar + (br - ar) * t);
    const rg = Math.round(ag + (bg - ag) * t);
    const rb = Math.round(ab + (bb - ab) * t);
    return `rgb(${rr},${rg},${rb})`;
  }

  function getCurrentPalette(time) {
    const elapsed = time - colorPhaseStart;
    const totalCycle = PHASE_DURATION * colorPhases.length;
    const cycleTime = elapsed % totalCycle;
    const phaseIndex = Math.floor(cycleTime / PHASE_DURATION);
    const nextPhaseIndex = (phaseIndex + 1) % colorPhases.length;
    const phaseProgress = (cycleTime % PHASE_DURATION) / PHASE_DURATION;

    const transitionZone = 0.2;
    const currentPhase = colorPhases[phaseIndex];
    const nextPhase = colorPhases[nextPhaseIndex];

    if (phaseProgress > 1 - transitionZone) {
      const t = (phaseProgress - (1 - transitionZone)) / transitionZone;
      const smoothT = t * t * (3 - 2 * t);
      return currentPhase.map((c, i) => lerpColor(c, nextPhase[i], smoothT));
    }
    return currentPhase;
  }

  function getRandomFromPalette(time) {
    const pal = getCurrentPalette(time);
    return pal[Math.floor(Math.random() * pal.length)];
  }

  // --- Sound Engine ---
  let audioCtx = null;

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // Also request motion permission on first user gesture (iOS requirement)
    requestMotionPermission();
  }

  const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
  let noteIndex = 0;

  function playChord() {
    if (!audioCtx) return;
    const baseIdx = noteIndex % pentatonic.length;
    const intervals = [2, 4];
    const interval = intervals[Math.floor(Math.random() * intervals.length)];
    const freqs = [
      pentatonic[baseIdx],
      pentatonic[(baseIdx + interval) % pentatonic.length],
    ];
    noteIndex++;

    freqs.forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = i === 0 ? 'sine' : 'triangle';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      const vol = i === 0 ? 0.12 : 0.06;
      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 1.6);
    });
  }

  // ==============================================
  // V3 IMPROVEMENT 2: Shape Morphing
  // ==============================================
  // Shape types as numeric indices for interpolation
  // 0=circle, 1=star, 2=roundedRect, 3=ring
  const SHAPE_TYPES = ['circle', 'star', 'roundedRect', 'ring'];

  const shapes = [];
  const SHAPE_COUNT = 10;

  function createShape(x, y) {
    const typeIdx = Math.floor(Math.random() * SHAPE_TYPES.length);
    return {
      baseX: x !== undefined ? x : Math.random() * W(),
      baseY: y !== undefined ? y : Math.random() * H(),
      driftVx: (Math.random() - 0.5) * 0.15,
      driftVy: (Math.random() - 0.5) * 0.15,
      amplitudeX: 30 + Math.random() * 80,
      amplitudeY: 20 + Math.random() * 60,
      frequencyX: 0.0003 + Math.random() * 0.0006,
      frequencyY: 0.0004 + Math.random() * 0.0005,
      phaseX: Math.random() * Math.PI * 2,
      phaseY: Math.random() * Math.PI * 2,
      baseSize: 30 + Math.random() * 60,
      sizePulseAmp: 5 + Math.random() * 10,
      sizePulseFreq: 0.0008 + Math.random() * 0.001,
      sizePulsePhase: Math.random() * Math.PI * 2,
      x: 0, y: 0, size: 0,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.005,
      // Morphing: current shape and target shape
      morphFrom: typeIdx,
      morphTo: typeIdx,
      morphProgress: 1.0, // 1.0 = fully at morphTo
      morphSpeed: 0.0003 + Math.random() * 0.0003,
      morphTimer: 8000 + Math.random() * 15000, // ms until next morph
      morphCountdown: 8000 + Math.random() * 15000,
      colorIndex: Math.floor(Math.random() * 5),
      alpha: 0.6 + Math.random() * 0.4,
      phase: Math.random() * Math.PI * 2,
      pushVx: 0,
      pushVy: 0,
    };
  }

  for (let i = 0; i < SHAPE_COUNT; i++) {
    shapes.push(createShape());
  }

  // --- Drawing helpers ---

  // Generate points for each shape type as a polygon (for morphing)
  function getShapePoints(type, cx, cy, size, rotation, numPoints) {
    const points = [];
    numPoints = numPoints || 32;

    switch (type) {
      case 0: // circle
        for (let i = 0; i < numPoints; i++) {
          const a = (Math.PI * 2 * i) / numPoints + rotation;
          points.push({ x: cx + Math.cos(a) * size, y: cy + Math.sin(a) * size });
        }
        break;

      case 1: // star (5 points)
        for (let i = 0; i < numPoints; i++) {
          const a = (Math.PI * 2 * i) / numPoints + rotation;
          // Star radius oscillates between full and 45%
          const starPhase = (i / numPoints) * 5; // 5-pointed
          const r = size * (0.725 + 0.275 * Math.cos(starPhase * Math.PI * 2));
          points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
        }
        break;

      case 2: // roundedRect
        {
          const half = size * 0.8;
          const corner = size * 0.25;
          for (let i = 0; i < numPoints; i++) {
            const t = i / numPoints;
            let px, py;
            const perim = (half - corner) * 8 + 2 * Math.PI * corner;
            const segLen = (half - corner) * 2;
            const cornerLen = Math.PI * corner / 2;
            const totalSeg = segLen * 4 + cornerLen * 4;
            let d = t * totalSeg;

            // Walk the rounded rect perimeter
            if (d < segLen) { px = -half + corner + d; py = -half; }
            else if ((d -= segLen) < cornerLen) { const a = -Math.PI/2 + (d/cornerLen) * (Math.PI/2); px = half - corner + Math.cos(a) * corner; py = -half + corner + Math.sin(a) * corner; }
            else if ((d -= cornerLen) < segLen) { px = half; py = -half + corner + d; }
            else if ((d -= segLen) < cornerLen) { const a = 0 + (d/cornerLen) * (Math.PI/2); px = half - corner + Math.cos(a) * corner; py = half - corner + Math.sin(a) * corner; }
            else if ((d -= cornerLen) < segLen) { px = half - corner - d; py = half; }
            else if ((d -= segLen) < cornerLen) { const a = Math.PI/2 + (d/cornerLen) * (Math.PI/2); px = -half + corner + Math.cos(a) * corner; py = half - corner + Math.sin(a) * corner; }
            else if ((d -= cornerLen) < segLen) { px = -half; py = half - corner - d; }
            else { const a = Math.PI + (Math.min(d, cornerLen)/cornerLen) * (Math.PI/2); px = -half + corner + Math.cos(a) * corner; py = -half + corner + Math.sin(a) * corner; }

            // Apply rotation
            const cos = Math.cos(rotation), sin = Math.sin(rotation);
            points.push({ x: cx + px * cos - py * sin, y: cy + px * sin + py * cos });
          }
        }
        break;

      case 3: // ring (draw as thick circle - outer edge)
        for (let i = 0; i < numPoints; i++) {
          const a = (Math.PI * 2 * i) / numPoints + rotation;
          // Pulsate between inner and outer ring radius for a wobbly ring effect
          const wobble = 0.8 + 0.2 * Math.sin(i * 0.5);
          points.push({ x: cx + Math.cos(a) * size * wobble, y: cy + Math.sin(a) * size * wobble });
        }
        break;
    }
    return points;
  }

  function drawMorphedShape(s, time) {
    const numPoints = 48;
    const fromPoints = getShapePoints(s.morphFrom, s.x, s.y, s.size, s.rotation, numPoints);
    const toPoints = getShapePoints(s.morphTo, s.x, s.y, s.size, s.rotation, numPoints);

    // Smoothstep the morph progress
    const t = s.morphProgress;
    const smooth = t * t * (3 - 2 * t);

    ctx.save();
    ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + s.phase));
    ctx.fillStyle = s.color || '#fff';
    ctx.strokeStyle = s.color || '#fff';
    ctx.lineWidth = 3;

    ctx.beginPath();
    for (let i = 0; i < numPoints; i++) {
      const px = fromPoints[i].x + (toPoints[i].x - fromPoints[i].x) * smooth;
      const py = fromPoints[i].y + (toPoints[i].y - fromPoints[i].y) * smooth;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();

    // Rings get stroked, everything else filled
    const currentType = smooth > 0.5 ? s.morphTo : s.morphFrom;
    if (currentType === 3) {
      ctx.stroke();
    } else {
      ctx.fill();
    }

    ctx.restore();
  }

  function updateShape(s, time, dt) {
    // Gravity from accelerometer
    const gravForce = 0.3;
    s.driftVx += gravityX * gravForce * 0.016;
    s.driftVy += gravityY * gravForce * 0.016;

    // Slight friction so shapes don't fly off forever
    s.driftVx *= 0.999;
    s.driftVy *= 0.999;

    // Drift + push
    s.baseX += s.driftVx + s.pushVx;
    s.baseY += s.driftVy + s.pushVy;
    s.pushVx *= 0.96;
    s.pushVy *= 0.96;

    // Organic sine-wave motion
    s.x = s.baseX + Math.sin(time * s.frequencyX + s.phaseX) * s.amplitudeX;
    s.y = s.baseY + Math.cos(time * s.frequencyY + s.phaseY) * s.amplitudeY;

    // Size breathing
    s.size = s.baseSize + Math.sin(time * s.sizePulseFreq + s.sizePulsePhase) * s.sizePulseAmp;

    s.rotation += s.rotSpeed;

    // Color evolution
    const pal = getCurrentPalette(time);
    s.color = pal[s.colorIndex % pal.length];

    // === Morphing logic ===
    if (s.morphProgress < 1.0) {
      // Currently morphing
      s.morphProgress = Math.min(1.0, s.morphProgress + s.morphSpeed * (dt || 16));
    } else {
      // Countdown to next morph
      s.morphCountdown -= (dt || 16);
      if (s.morphCountdown <= 0) {
        // Start a new morph to a different shape
        s.morphFrom = s.morphTo;
        let newType;
        do {
          newType = Math.floor(Math.random() * SHAPE_TYPES.length);
        } while (newType === s.morphFrom);
        s.morphTo = newType;
        s.morphProgress = 0;
        s.morphCountdown = s.morphTimer;
      }
    }

    // Wrap around edges
    const pad = s.baseSize + 100;
    if (s.baseX < -pad) s.baseX = W() + pad;
    if (s.baseX > W() + pad) s.baseX = -pad;
    if (s.baseY < -pad) s.baseY = H() + pad;
    if (s.baseY > H() + pad) s.baseY = -pad;
  }

  // --- Simple shape draw (for bloom/particles that don't morph) ---
  function drawStar(cx, cy, r, points, rotation) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const angle = (i * Math.PI / points) + rotation;
      const rad = i % 2 === 0 ? r : r * 0.45;
      const sx = cx + Math.cos(angle) * rad;
      const sy = cy + Math.sin(angle) * rad;
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
  }

  function drawSimpleShape(s, time) {
    ctx.save();
    ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + (s.phase || 0)));
    ctx.fillStyle = s.color || '#fff';
    ctx.strokeStyle = s.color || '#fff';
    ctx.lineWidth = 3;
    const drawSize = s.size || s.baseSize || 20;

    switch (s.type) {
      case 'circle':
        ctx.beginPath();
        ctx.arc(s.x, s.y, drawSize, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 'star':
        drawStar(s.x, s.y, drawSize, 5, s.rotation || 0);
        ctx.fill();
        break;
      case 'roundedRect': {
        const half = drawSize * 0.8;
        const r = drawSize * 0.25;
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rotation || 0);
        ctx.beginPath();
        ctx.moveTo(-half + r, -half);
        ctx.lineTo(half - r, -half);
        ctx.quadraticCurveTo(half, -half, half, -half + r);
        ctx.lineTo(half, half - r);
        ctx.quadraticCurveTo(half, half, half - r, half);
        ctx.lineTo(-half + r, half);
        ctx.quadraticCurveTo(-half, half, -half, half - r);
        ctx.lineTo(-half, -half + r);
        ctx.quadraticCurveTo(-half, -half, -half + r, -half);
        ctx.closePath();
        ctx.fill();
        break;
      }
      case 'ring':
        ctx.beginPath();
        ctx.arc(s.x, s.y, drawSize, 0, Math.PI * 2);
        ctx.stroke();
        break;
    }
    ctx.restore();
  }

  // --- Tap Particles ---
  const particles = [];

  function spawnParticles(x, y, count, time) {
    const color = getRandomFromPalette(time);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
      const speed = 1.5 + Math.random() * 3;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 4 + Math.random() * 12,
        life: 1.0,
        decay: 0.008 + Math.random() * 0.012,
        color,
        type: Math.random() > 0.5 ? 'circle' : 'star',
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.1,
      });
    }
  }

  // --- Tap Ripples ---
  const ripples = [];

  function spawnRipple(x, y, time) {
    for (let r = 0; r < 3; r++) {
      ripples.push({
        x, y,
        radius: 5 + r * 8,
        maxRadius: 100 + Math.random() * 80 + r * 30,
        alpha: 0.5 - r * 0.12,
        color: getRandomFromPalette(time),
      });
    }
  }

  // --- Tap Bloom Shapes ---
  const bloomShapes = [];

  function spawnBloomShapes(x, y, time) {
    const count = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 0.5 + Math.random() * 1.5;
      bloomShapes.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 15 + Math.random() * 30,
        life: 1.0,
        decay: 0.006 + Math.random() * 0.006,
        color: getRandomFromPalette(time),
        type: ['circle', 'star', 'roundedRect'][Math.floor(Math.random() * 3)],
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.03,
        alpha: 0.8,
      });
    }
  }

  // --- Glows ---
  const glows = [];

  function spawnGlow(x, y, time) {
    glows.push({
      x, y,
      radius: 20,
      maxRadius: 120,
      alpha: 0.4,
      color: getRandomFromPalette(time),
    });
  }

  // --- Trail Particles ---
  const trailParticles = [];
  let lastDragPos = null;

  function spawnTrailParticle(x, y, time) {
    trailParticles.push({
      x, y,
      size: 3 + Math.random() * 8,
      life: 1.0,
      decay: 0.015 + Math.random() * 0.01,
      color: getRandomFromPalette(time),
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
    });
  }

  // --- Push nearby shapes ---
  function pushNearbyShapes(x, y) {
    const pushRadius = 200;
    for (const s of shapes) {
      const dx = s.x - x;
      const dy = s.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < pushRadius && dist > 0) {
        const force = (1 - dist / pushRadius) * 3;
        s.pushVx += (dx / dist) * force;
        s.pushVy += (dy / dist) * force;
        s.sizePulseAmp = Math.min(s.sizePulseAmp + 3, 25);
      }
    }
  }

  // --- Heartbeat Pulse ---
  let heartbeatPhase = 0;

  // --- Touch/Click Handler ---
  function handleInteraction(x, y, time) {
    initAudio();
    playChord();
    spawnParticles(x, y, 14, time);
    spawnRipple(x, y, time);
    spawnBloomShapes(x, y, time);
    spawnGlow(x, y, time);
    pushNearbyShapes(x, y);
  }

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    handleInteraction(e.clientX, e.clientY, performance.now());
    lastDragPos = { x: e.clientX, y: e.clientY };
  });

  canvas.addEventListener('pointermove', (e) => {
    if (e.buttons > 0 || e.pointerType === 'touch') {
      const now = performance.now();
      if (lastDragPos) {
        const dx = e.clientX - lastDragPos.x;
        const dy = e.clientY - lastDragPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 5) {
          spawnTrailParticle(e.clientX, e.clientY, now);
          lastDragPos = { x: e.clientX, y: e.clientY };
        }
      } else {
        lastDragPos = { x: e.clientX, y: e.clientY };
      }
    }
  });

  canvas.addEventListener('pointerup', () => { lastDragPos = null; });

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const now = performance.now();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const t = e.changedTouches[i];
      handleInteraction(t.clientX, t.clientY, now);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const now = performance.now();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const t = e.changedTouches[i];
      spawnTrailParticle(t.clientX, t.clientY, now);
    }
  }, { passive: false });

  // --- Main Loop ---
  let lastTime = 0;

  function frame(time) {
    const dt = lastTime ? time - lastTime : 16;
    lastTime = time;

    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    const w = W(), h = H();

    // Heartbeat background pulse
    heartbeatPhase += 0.015;
    const pulse = Math.sin(heartbeatPhase) * 0.5 + 0.5;
    const bgBright = 8 + pulse * 6;
    ctx.fillStyle = `rgb(${bgBright}, ${bgBright}, ${bgBright + 4})`;
    ctx.fillRect(0, 0, w, h);

    // Draw twinkling stars (behind everything)
    drawStars(time);

    // Draw floating morphing shapes
    for (const s of shapes) {
      updateShape(s, time, dt);
      drawMorphedShape(s, time);
    }

    // Draw glows
    for (let i = glows.length - 1; i >= 0; i--) {
      const g = glows[i];
      g.radius += 1.5;
      g.alpha -= 0.005;
      if (g.alpha <= 0 || g.radius >= g.maxRadius) {
        glows.splice(i, 1);
        continue;
      }
      ctx.save();
      const gradient = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.radius);
      gradient.addColorStop(0, g.color);
      gradient.addColorStop(1, 'transparent');
      ctx.globalAlpha = g.alpha;
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // Draw ripples
    for (let i = ripples.length - 1; i >= 0; i--) {
      const r = ripples[i];
      r.radius += 1.8;
      r.alpha -= 0.008;
      if (r.alpha <= 0 || r.radius >= r.maxRadius) {
        ripples.splice(i, 1);
        continue;
      }
      ctx.save();
      ctx.globalAlpha = r.alpha;
      ctx.strokeStyle = r.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    // Draw bloom shapes
    for (let i = bloomShapes.length - 1; i >= 0; i--) {
      const b = bloomShapes[i];
      // Gravity affects bloom shapes too
      b.vx += gravityX * 0.02;
      b.vy += gravityY * 0.02;
      b.x += b.vx;
      b.y += b.vy;
      b.vx *= 0.99;
      b.vy *= 0.99;
      b.rotation += b.rotSpeed;
      b.life -= b.decay;
      if (b.life <= 0) {
        bloomShapes.splice(i, 1);
        continue;
      }
      const s = { ...b, alpha: b.life * b.alpha, size: b.size };
      drawSimpleShape(s, time);
    }

    // Draw particles (gravity-affected)
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      // Device gravity affects particles
      p.vx += gravityX * 0.05;
      p.vy += gravityY * 0.05;
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.vy += 0.02; // base gravity
      p.life -= p.decay;
      p.rotation += p.rotSpeed;

      if (p.life <= 0) {
        particles.splice(i, 1);
        continue;
      }

      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      if (p.type === 'circle') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      } else {
        drawStar(p.x, p.y, p.size * p.life, 5, p.rotation);
        ctx.fill();
      }
      ctx.restore();
    }

    // Draw trail particles
    for (let i = trailParticles.length - 1; i >= 0; i--) {
      const tp = trailParticles[i];
      tp.vx += gravityX * 0.03;
      tp.vy += gravityY * 0.03;
      tp.x += tp.vx;
      tp.y += tp.vy;
      tp.life -= tp.decay;

      if (tp.life <= 0) {
        trailParticles.splice(i, 1);
        continue;
      }

      ctx.save();
      ctx.globalAlpha = tp.life * 0.7;
      const gradient = ctx.createRadialGradient(tp.x, tp.y, 0, tp.x, tp.y, tp.size * tp.life);
      gradient.addColorStop(0, tp.color);
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(tp.x, tp.y, tp.size * tp.life, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    requestAnimationFrame(frame);
  }

  // Init stars and start
  resize();
  requestAnimationFrame(frame);

  // --- Fullscreen on first interaction (mobile) ---
  let hasRequestedFullscreen = false;
  document.addEventListener('click', () => {
    if (hasRequestedFullscreen) return;
    hasRequestedFullscreen = true;
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  }, { once: false });

})();
</script>
</body>
</html>
