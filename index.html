<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Baby World</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a0f;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: default;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  #face {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 180px; height: 180px;
    pointer-events: none;
    z-index: 10;
    animation: breathe 4s ease-in-out infinite;
  }
  @keyframes breathe {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
  }
  .eye-lid {
    transform-origin: center;
    animation: blink 4s ease-in-out infinite;
  }
  .eye-lid-right {
    animation-delay: 0.1s;
  }
  @keyframes blink {
    0%, 90%, 100% { transform: scaleY(1); }
    95% { transform: scaleY(0.05); }
  }
</style>
</head>
<body>

<svg id="face" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- Face circle -->
  <circle cx="100" cy="100" r="90" fill="#fff" stroke="#e0e0e0" stroke-width="2"/>
  <!-- Left eye -->
  <g class="eye-lid">
    <ellipse cx="70" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
    <ellipse cx="74" cy="78" rx="6" ry="7" fill="#fff"/>
  </g>
  <!-- Right eye -->
  <g class="eye-lid eye-lid-right">
    <ellipse cx="130" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
    <ellipse cx="134" cy="78" rx="6" ry="7" fill="#fff"/>
  </g>
  <!-- Rosy cheeks -->
  <ellipse cx="50" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <ellipse cx="150" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <!-- Smile -->
  <path d="M 70 120 Q 100 150 130 120" stroke="#1a1a2e" stroke-width="4" fill="none" stroke-linecap="round"/>
</svg>

<canvas id="canvas"></canvas>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // --- Resize ---
  function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  window.addEventListener('resize', resize);
  resize();

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  // --- Color Palette ---
  const palette = [
    '#ffffff', '#f0f0f0',           // whites
    '#ff4444', '#ff6b6b',           // reds
    '#4488ff', '#66aaff',           // blues
    '#ffdd44', '#ffee77',           // yellows
    '#44dd88', '#77eebb',           // greens
  ];

  // --- Sound Engine (Web Audio API) ---
  let audioCtx = null;

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  // Pentatonic scale frequencies (C4, D4, E4, G4, A4, C5, D5, E5)
  const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
  let noteIndex = 0;

  function playNote() {
    if (!audioCtx) return;
    const freq = pentatonic[noteIndex % pentatonic.length];
    noteIndex++;

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

    // Soft envelope
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 1.3);
  }

  // --- Floating Shapes ---
  const shapes = [];
  const SHAPE_COUNT = 8;

  function createShape(x, y) {
    const types = ['circle', 'star', 'roundedRect', 'ring'];
    return {
      x: x !== undefined ? x : Math.random() * W(),
      y: y !== undefined ? y : Math.random() * H(),
      vx: (Math.random() - 0.5) * 0.4,
      vy: (Math.random() - 0.5) * 0.4,
      size: 30 + Math.random() * 60,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.008,
      type: types[Math.floor(Math.random() * types.length)],
      color: palette[Math.floor(Math.random() * palette.length)],
      alpha: 0.6 + Math.random() * 0.4,
      phase: Math.random() * Math.PI * 2,
    };
  }

  for (let i = 0; i < SHAPE_COUNT; i++) {
    shapes.push(createShape());
  }

  function drawStar(cx, cy, r, points, rotation) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const angle = (i * Math.PI / points) + rotation;
      const rad = i % 2 === 0 ? r : r * 0.45;
      const sx = cx + Math.cos(angle) * rad;
      const sy = cy + Math.sin(angle) * rad;
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
  }

  function drawShape(s, time) {
    ctx.save();
    ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + s.phase));
    ctx.fillStyle = s.color;
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 3;

    switch (s.type) {
      case 'circle':
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
        break;
      case 'star':
        drawStar(s.x, s.y, s.size, 5, s.rotation);
        ctx.fill();
        break;
      case 'roundedRect': {
        const half = s.size * 0.8;
        const r = s.size * 0.25;
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rotation);
        ctx.beginPath();
        ctx.moveTo(-half + r, -half);
        ctx.lineTo(half - r, -half);
        ctx.quadraticCurveTo(half, -half, half, -half + r);
        ctx.lineTo(half, half - r);
        ctx.quadraticCurveTo(half, half, half - r, half);
        ctx.lineTo(-half + r, half);
        ctx.quadraticCurveTo(-half, half, -half, half - r);
        ctx.lineTo(-half, -half + r);
        ctx.quadraticCurveTo(-half, -half, -half + r, -half);
        ctx.closePath();
        ctx.fill();
        break;
      }
      case 'ring':
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        break;
    }
    ctx.restore();
  }

  function updateShape(s) {
    s.x += s.vx;
    s.y += s.vy;
    s.rotation += s.rotSpeed;

    // Wrap around edges with padding
    const pad = s.size + 20;
    if (s.x < -pad) s.x = W() + pad;
    if (s.x > W() + pad) s.x = -pad;
    if (s.y < -pad) s.y = H() + pad;
    if (s.y > H() + pad) s.y = -pad;
  }

  // --- Tap Particles ---
  const particles = [];

  function spawnParticles(x, y, count) {
    const color = palette[Math.floor(Math.random() * palette.length)];
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
      const speed = 1.5 + Math.random() * 3;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 4 + Math.random() * 12,
        life: 1.0,
        decay: 0.008 + Math.random() * 0.012,
        color,
        type: Math.random() > 0.5 ? 'circle' : 'star',
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.1,
      });
    }
  }

  // --- Tap Ripples ---
  const ripples = [];

  function spawnRipple(x, y) {
    ripples.push({
      x, y,
      radius: 10,
      maxRadius: 100 + Math.random() * 80,
      alpha: 0.6,
      color: palette[Math.floor(Math.random() * palette.length)],
    });
  }

  // --- Tap Bloom Shapes ---
  const bloomShapes = [];

  function spawnBloomShapes(x, y) {
    const count = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 0.5 + Math.random() * 1.5;
      bloomShapes.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size: 15 + Math.random() * 30,
        life: 1.0,
        decay: 0.006 + Math.random() * 0.006,
        color: palette[Math.floor(Math.random() * palette.length)],
        type: ['circle', 'star', 'roundedRect'][Math.floor(Math.random() * 3)],
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.03,
        alpha: 0.8,
      });
    }
  }

  // --- Heartbeat Pulse ---
  let heartbeatPhase = 0;

  // --- Touch/Click Handler ---
  function handleInteraction(x, y) {
    initAudio();
    playNote();
    spawnParticles(x, y, 12);
    spawnRipple(x, y);
    spawnBloomShapes(x, y);
  }

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    handleInteraction(e.clientX, e.clientY);
  });

  // Support multi-touch
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const t = e.changedTouches[i];
      handleInteraction(t.clientX, t.clientY);
    }
  }, { passive: false });

  // Prevent scrolling/zooming
  document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

  // --- Main Loop ---
  function frame(time) {
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    const w = W(), h = H();

    // Heartbeat background pulse
    heartbeatPhase += 0.015; // ~60bpm feel
    const pulse = Math.sin(heartbeatPhase) * 0.5 + 0.5;
    const bgBright = 8 + pulse * 6;
    ctx.fillStyle = `rgb(${bgBright}, ${bgBright}, ${bgBright + 4})`;
    ctx.fillRect(0, 0, w, h);

    // Draw floating shapes
    for (const s of shapes) {
      updateShape(s);
      drawShape(s, time);
    }

    // Draw & update ripples
    for (let i = ripples.length - 1; i >= 0; i--) {
      const r = ripples[i];
      r.radius += 2;
      r.alpha -= 0.01;
      if (r.alpha <= 0 || r.radius >= r.maxRadius) {
        ripples.splice(i, 1);
        continue;
      }
      ctx.save();
      ctx.globalAlpha = r.alpha;
      ctx.strokeStyle = r.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    // Draw & update bloom shapes
    for (let i = bloomShapes.length - 1; i >= 0; i--) {
      const b = bloomShapes[i];
      b.x += b.vx;
      b.y += b.vy;
      b.vx *= 0.99;
      b.vy *= 0.99;
      b.rotation += b.rotSpeed;
      b.life -= b.decay;
      if (b.life <= 0) {
        bloomShapes.splice(i, 1);
        continue;
      }
      const s = { ...b, alpha: b.life * b.alpha };
      drawShape(s, time);
    }

    // Draw & update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.vy += 0.02; // slight gravity
      p.life -= p.decay;
      p.rotation += p.rotSpeed;

      if (p.life <= 0) {
        particles.splice(i, 1);
        continue;
      }

      ctx.save();
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      if (p.type === 'circle') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
      } else {
        drawStar(p.x, p.y, p.size * p.life, 5, p.rotation);
        ctx.fill();
      }
      ctx.restore();
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

  // --- Fullscreen on first interaction (mobile) ---
  let hasRequestedFullscreen = false;
  document.addEventListener('click', () => {
    if (hasRequestedFullscreen) return;
    hasRequestedFullscreen = true;
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  }, { once: false });

})();
</script>
</body>
</html>
