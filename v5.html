<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Baby World v5</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a0f;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: default;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  #face {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 180px; height: 180px;
    pointer-events: none;
    z-index: 10;
    animation: breathe 4s ease-in-out infinite;
    transition: width 0.3s, height 0.3s;
  }
  @keyframes breathe {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
  }
</style>
</head>
<body>

<svg id="face" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <circle cx="100" cy="100" r="90" fill="#fff" stroke="#e0e0e0" stroke-width="2"/>
  <ellipse id="eyeL" cx="70" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
  <ellipse id="pupilL" cx="74" cy="78" rx="6" ry="7" fill="#fff"/>
  <ellipse id="eyeR" cx="130" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
  <ellipse id="pupilR" cx="134" cy="78" rx="6" ry="7" fill="#fff"/>
  <ellipse id="cheekL" cx="50" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <ellipse id="cheekR" cx="150" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <path id="mouth" d="M 70 120 Q 100 150 130 120" stroke="#1a1a2e" stroke-width="4" fill="none" stroke-linecap="round"/>
</svg>

<canvas id="canvas"></canvas>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const eyeL = document.getElementById('eyeL');
  const eyeR = document.getElementById('eyeR');
  const pupilL = document.getElementById('pupilL');
  const pupilR = document.getElementById('pupilR');
  const cheekL = document.getElementById('cheekL');
  const cheekR = document.getElementById('cheekR');
  const mouth = document.getElementById('mouth');
  const faceSvg = document.getElementById('face');

  function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    initStars();
  }
  window.addEventListener('resize', resize);

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  // ==============================================
  // V5 FEATURE 1: Lullaby / Sleep Mode
  // ==============================================
  let lastInteractionTime = performance.now();
  let lullabyAmount = 0; // 0 = fully awake, 1 = fully asleep
  const LULLABY_IDLE_THRESHOLD = 60000; // 60s of no touch to start
  const LULLABY_TRANSITION_TIME = 30000; // 30s to fully transition

  function updateLullaby(time) {
    const idleTime = time - lastInteractionTime;
    if (idleTime > LULLABY_IDLE_THRESHOLD) {
      const transitionProgress = Math.min(1, (idleTime - LULLABY_IDLE_THRESHOLD) / LULLABY_TRANSITION_TIME);
      lullabyAmount += (transitionProgress - lullabyAmount) * 0.01;
    } else {
      // Wake up quickly on interaction
      lullabyAmount *= 0.95;
      if (lullabyAmount < 0.01) lullabyAmount = 0;
    }
  }

  // ==============================================
  // Twinkling Star Field
  // ==============================================
  const stars = [];
  const STAR_COUNT = 80;

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({
        x: Math.random() * W(),
        y: Math.random() * H(),
        baseSize: 0.5 + Math.random() * 2,
        twinkleSpeed: 0.001 + Math.random() * 0.003,
        twinklePhase: Math.random() * Math.PI * 2,
        baseAlpha: 0.2 + Math.random() * 0.5,
      });
    }
  }

  function drawStars(time) {
    // Stars get brighter during lullaby mode
    const brightBoost = 1 + lullabyAmount * 1.5;
    for (const star of stars) {
      const twinkle = Math.sin(time * star.twinkleSpeed + star.twinklePhase);
      const alpha = Math.min(1, star.baseAlpha * (0.3 + 0.7 * (twinkle * 0.5 + 0.5)) * brightBoost);
      const size = star.baseSize * (0.8 + 0.4 * (twinkle * 0.5 + 0.5));
      ctx.save();
      ctx.globalAlpha = alpha;
      const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, size * 3);
      gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.4, 'rgba(200,210,255,0.3)');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(star.x, star.y, size * 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ==============================================
  // Color Evolution — shifts to deep blue/purple in lullaby
  // ==============================================
  const colorPhases = [
    ['#ffffff', '#e0e0e0', '#c0c0c0', '#d0d0d0', '#f5f5f5'],
    ['#ffffff', '#e0e0e0', '#ff4444', '#ff6b6b', '#ffaaaa'],
    ['#ffffff', '#ff4444', '#4488ff', '#66aaff', '#aaccff'],
    ['#ff4444', '#ff6b6b', '#ffdd44', '#ffee77', '#ffaa33'],
    ['#4488ff', '#66aaff', '#44dd88', '#77eebb', '#88ddff'],
    ['#ff4444', '#ffdd44', '#44dd88', '#4488ff', '#cc66ff'],
  ];

  const lullabyPalette = ['#334477', '#2a3366', '#443377', '#3a4488', '#554499'];

  const PHASE_DURATION = 45000;
  let colorPhaseStart = performance.now();

  function lerpColor(a, b, t) {
    // Handle both hex and rgb() format
    let ar, ag, ab, br, bg, bb;
    if (a.startsWith('#')) {
      const ah = parseInt(a.slice(1), 16);
      ar = (ah >> 16) & 0xff; ag = (ah >> 8) & 0xff; ab = ah & 0xff;
    } else {
      const m = a.match(/(\d+)/g);
      ar = +m[0]; ag = +m[1]; ab = +m[2];
    }
    if (b.startsWith('#')) {
      const bh = parseInt(b.slice(1), 16);
      br = (bh >> 16) & 0xff; bg = (bh >> 8) & 0xff; bb = bh & 0xff;
    } else {
      const m = b.match(/(\d+)/g);
      br = +m[0]; bg = +m[1]; bb = +m[2];
    }
    return `rgb(${Math.round(ar + (br - ar) * t)},${Math.round(ag + (bg - ag) * t)},${Math.round(ab + (bb - ab) * t)})`;
  }

  function getCurrentPalette(time) {
    const elapsed = time - colorPhaseStart;
    const totalCycle = PHASE_DURATION * colorPhases.length;
    const cycleTime = elapsed % totalCycle;
    const phaseIndex = Math.floor(cycleTime / PHASE_DURATION);
    const nextPhaseIndex = (phaseIndex + 1) % colorPhases.length;
    const phaseProgress = (cycleTime % PHASE_DURATION) / PHASE_DURATION;
    const transitionZone = 0.2;
    const currentPhase = colorPhases[phaseIndex];
    const nextPhase = colorPhases[nextPhaseIndex];

    let basePalette;
    if (phaseProgress > 1 - transitionZone) {
      const t = (phaseProgress - (1 - transitionZone)) / transitionZone;
      const smoothT = t * t * (3 - 2 * t);
      basePalette = currentPhase.map((c, i) => lerpColor(c, nextPhase[i], smoothT));
    } else {
      basePalette = currentPhase;
    }

    // Blend toward lullaby palette
    if (lullabyAmount > 0.01) {
      return basePalette.map((c, i) => lerpColor(c, lullabyPalette[i], lullabyAmount));
    }
    return basePalette;
  }

  function getRandomFromPalette(time) {
    const pal = getCurrentPalette(time);
    return pal[Math.floor(Math.random() * pal.length)];
  }

  // ==============================================
  // Sound Engine
  // ==============================================
  let audioCtx = null;

  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
  let noteIndex = 0;

  function playChord() {
    if (!audioCtx) return;
    const baseIdx = noteIndex % pentatonic.length;
    const intervals = [2, 4];
    const interval = intervals[Math.floor(Math.random() * intervals.length)];
    const freqs = [
      pentatonic[baseIdx],
      pentatonic[(baseIdx + interval) % pentatonic.length],
    ];
    noteIndex++;
    // Volume decreases in lullaby mode
    const volMult = 1 - lullabyAmount * 0.7;
    freqs.forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = i === 0 ? 'sine' : 'triangle';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      const vol = (i === 0 ? 0.12 : 0.06) * volMult;
      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 1.6);
    });
  }

  function playPopSound(pitch) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(pitch || 600, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.25);
  }

  // ==============================================
  // V5 FEATURE 3: Zone-specific sounds
  // ==============================================
  function playZoneSound(zone) {
    if (!audioCtx) return;
    const volMult = 1 - lullabyAmount * 0.7;
    switch(zone) {
      case 'top': { // sparkly high tinkle
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800 + Math.random() * 400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200 + Math.random() * 300, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.08 * volMult, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.7);
        break;
      }
      case 'bottom': { // deep bloom
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(120 + Math.random() * 60, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1 * volMult, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.9);
        break;
      }
      case 'left': { // wave swoosh - rising pitch
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(500, audioCtx.currentTime + 0.4);
        gain.gain.setValueAtTime(0.06 * volMult, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.6);
        break;
      }
      case 'right': { // wave swoosh - falling pitch
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(200, audioCtx.currentTime + 0.4);
        gain.gain.setValueAtTime(0.06 * volMult, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(audioCtx.currentTime); osc.stop(audioCtx.currentTime + 0.6);
        break;
      }
    }
  }

  // ==============================================
  // Shape Morphing (from v3)
  // ==============================================
  const SHAPE_TYPES = ['circle', 'star', 'roundedRect', 'ring'];
  const shapes = [];
  const SHAPE_COUNT = 10;

  function createShape(x, y) {
    const typeIdx = Math.floor(Math.random() * SHAPE_TYPES.length);
    return {
      baseX: x !== undefined ? x : Math.random() * W(),
      baseY: y !== undefined ? y : Math.random() * H(),
      driftVx: (Math.random() - 0.5) * 0.15,
      driftVy: (Math.random() - 0.5) * 0.15,
      amplitudeX: 30 + Math.random() * 80,
      amplitudeY: 20 + Math.random() * 60,
      frequencyX: 0.0003 + Math.random() * 0.0006,
      frequencyY: 0.0004 + Math.random() * 0.0005,
      phaseX: Math.random() * Math.PI * 2,
      phaseY: Math.random() * Math.PI * 2,
      baseSize: 30 + Math.random() * 60,
      sizePulseAmp: 5 + Math.random() * 10,
      sizePulseFreq: 0.0008 + Math.random() * 0.001,
      sizePulsePhase: Math.random() * Math.PI * 2,
      x: 0, y: 0, size: 0,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.005,
      morphFrom: typeIdx, morphTo: typeIdx, morphProgress: 1.0,
      morphSpeed: 0.0003 + Math.random() * 0.0003,
      morphTimer: 8000 + Math.random() * 15000,
      morphCountdown: 8000 + Math.random() * 15000,
      colorIndex: Math.floor(Math.random() * 5),
      alpha: 0.6 + Math.random() * 0.4,
      phase: Math.random() * Math.PI * 2,
      pushVx: 0, pushVy: 0,
    };
  }
  for (let i = 0; i < SHAPE_COUNT; i++) shapes.push(createShape());

  function getShapePoints(type, cx, cy, size, rotation, numPoints) {
    const points = [];
    numPoints = numPoints || 32;
    switch (type) {
      case 0:
        for (let i = 0; i < numPoints; i++) { const a = (Math.PI * 2 * i) / numPoints + rotation; points.push({ x: cx + Math.cos(a) * size, y: cy + Math.sin(a) * size }); } break;
      case 1:
        for (let i = 0; i < numPoints; i++) { const a = (Math.PI * 2 * i) / numPoints + rotation; const sp = (i / numPoints) * 5; const r = size * (0.725 + 0.275 * Math.cos(sp * Math.PI * 2)); points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r }); } break;
      case 2: {
        const half = size * 0.8; const corner = size * 0.25;
        for (let i = 0; i < numPoints; i++) { const t = i / numPoints; let px, py; const segLen = (half - corner) * 2; const cornerLen = Math.PI * corner / 2; let d = t * (segLen * 4 + cornerLen * 4);
          if (d < segLen) { px = -half + corner + d; py = -half; }
          else if ((d -= segLen) < cornerLen) { const a = -Math.PI/2 + (d/cornerLen) * (Math.PI/2); px = half - corner + Math.cos(a) * corner; py = -half + corner + Math.sin(a) * corner; }
          else if ((d -= cornerLen) < segLen) { px = half; py = -half + corner + d; }
          else if ((d -= segLen) < cornerLen) { const a = (d/cornerLen) * (Math.PI/2); px = half - corner + Math.cos(a) * corner; py = half - corner + Math.sin(a) * corner; }
          else if ((d -= cornerLen) < segLen) { px = half - corner - d; py = half; }
          else if ((d -= segLen) < cornerLen) { const a = Math.PI/2 + (d/cornerLen) * (Math.PI/2); px = -half + corner + Math.cos(a) * corner; py = half - corner + Math.sin(a) * corner; }
          else if ((d -= cornerLen) < segLen) { px = -half; py = half - corner - d; }
          else { const a = Math.PI + (Math.min(d, cornerLen)/cornerLen) * (Math.PI/2); px = -half + corner + Math.cos(a) * corner; py = -half + corner + Math.sin(a) * corner; }
          const cos = Math.cos(rotation), sin = Math.sin(rotation);
          points.push({ x: cx + px * cos - py * sin, y: cy + px * sin + py * cos }); } break;
      }
      case 3:
        for (let i = 0; i < numPoints; i++) { const a = (Math.PI * 2 * i) / numPoints + rotation; const wobble = 0.8 + 0.2 * Math.sin(i * 0.5); points.push({ x: cx + Math.cos(a) * size * wobble, y: cy + Math.sin(a) * size * wobble }); } break;
    }
    return points;
  }

  function drawMorphedShape(s, time) {
    const numPoints = 48;
    const fromPts = getShapePoints(s.morphFrom, s.x, s.y, s.size, s.rotation, numPoints);
    const toPts = getShapePoints(s.morphTo, s.x, s.y, s.size, s.rotation, numPoints);
    const t = s.morphProgress; const smooth = t * t * (3 - 2 * t);
    ctx.save();
    // Dim shapes in lullaby mode
    ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + s.phase)) * (1 - lullabyAmount * 0.5);
    ctx.fillStyle = s.color || '#fff'; ctx.strokeStyle = s.color || '#fff'; ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < numPoints; i++) {
      const px = fromPts[i].x + (toPts[i].x - fromPts[i].x) * smooth;
      const py = fromPts[i].y + (toPts[i].y - fromPts[i].y) * smooth;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
    if ((smooth > 0.5 ? s.morphTo : s.morphFrom) === 3) ctx.stroke(); else ctx.fill();
    ctx.restore();
  }

  function updateShape(s, time, dt) {
    // Shapes slow down in lullaby mode
    const speedMult = 1 - lullabyAmount * 0.7;
    s.driftVx *= 0.999;
    s.driftVy *= 0.999;
    s.baseX += (s.driftVx + s.pushVx) * speedMult;
    s.baseY += (s.driftVy + s.pushVy) * speedMult;
    s.pushVx *= 0.96; s.pushVy *= 0.96;
    s.x = s.baseX + Math.sin(time * s.frequencyX * speedMult + s.phaseX) * s.amplitudeX;
    s.y = s.baseY + Math.cos(time * s.frequencyY * speedMult + s.phaseY) * s.amplitudeY;
    s.size = s.baseSize + Math.sin(time * s.sizePulseFreq + s.sizePulsePhase) * s.sizePulseAmp;
    s.rotation += s.rotSpeed * speedMult;
    const pal = getCurrentPalette(time);
    s.color = pal[s.colorIndex % pal.length];
    if (s.morphProgress < 1.0) { s.morphProgress = Math.min(1.0, s.morphProgress + s.morphSpeed * (dt || 16)); }
    else { s.morphCountdown -= (dt || 16); if (s.morphCountdown <= 0) { s.morphFrom = s.morphTo; let newType; do { newType = Math.floor(Math.random() * SHAPE_TYPES.length); } while (newType === s.morphFrom); s.morphTo = newType; s.morphProgress = 0; s.morphCountdown = s.morphTimer; } }
    const pad = s.baseSize + 100;
    if (s.baseX < -pad) s.baseX = W() + pad; if (s.baseX > W() + pad) s.baseX = -pad;
    if (s.baseY < -pad) s.baseY = H() + pad; if (s.baseY > H() + pad) s.baseY = -pad;
  }

  // ==============================================
  // V5 FEATURE 2: Shape Friends (animated creatures)
  // ==============================================
  const friends = [];

  function createFish(x, y) {
    return {
      type: 'fish', x: x || Math.random() * W(), y: y || Math.random() * H(),
      vx: (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.5),
      vy: (Math.random() - 0.5) * 0.2,
      size: 20 + Math.random() * 15, tailPhase: Math.random() * Math.PI * 2,
      colorIndex: Math.floor(Math.random() * 5),
    };
  }

  function createBird(x, y) {
    return {
      type: 'bird', x: x || Math.random() * W(), y: y || 50 + Math.random() * H() * 0.3,
      vx: (Math.random() > 0.5 ? 1 : -1) * (0.4 + Math.random() * 0.4),
      vy: 0, wingPhase: Math.random() * Math.PI * 2,
      size: 15 + Math.random() * 10,
      colorIndex: Math.floor(Math.random() * 5),
      swoopPhase: Math.random() * Math.PI * 2,
    };
  }

  function createButterfly(x, y) {
    return {
      type: 'butterfly', x: x || Math.random() * W(), y: y || Math.random() * H(),
      vx: (Math.random() - 0.5) * 0.4,
      vy: (Math.random() - 0.5) * 0.3,
      wingPhase: Math.random() * Math.PI * 2,
      size: 12 + Math.random() * 10,
      colorIndex: Math.floor(Math.random() * 5),
      flutterPhase: Math.random() * Math.PI * 2,
    };
  }

  // Spawn initial friends
  friends.push(createFish(), createFish());
  friends.push(createBird(), createBird());
  friends.push(createButterfly(), createButterfly());

  function drawFriend(f, time) {
    const pal = getCurrentPalette(time);
    const color = pal[f.colorIndex % pal.length];
    const speedMult = 1 - lullabyAmount * 0.7;
    ctx.save();
    ctx.globalAlpha = 0.8 * (1 - lullabyAmount * 0.4);

    switch (f.type) {
      case 'fish': {
        const tailWag = Math.sin(time * 0.008 * speedMult + f.tailPhase) * 0.3;
        const dir = f.vx > 0 ? 1 : -1;
        ctx.translate(f.x, f.y);
        ctx.scale(dir, 1);
        // Body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.ellipse(0, 0, f.size, f.size * 0.55, 0, 0, Math.PI * 2);
        ctx.fill();
        // Tail
        ctx.beginPath();
        ctx.moveTo(-f.size * 0.7, 0);
        ctx.lineTo(-f.size * 1.3, -f.size * 0.5 + tailWag * f.size);
        ctx.lineTo(-f.size * 1.3, f.size * 0.5 + tailWag * f.size);
        ctx.closePath();
        ctx.fill();
        // Eye
        ctx.fillStyle = '#1a1a2e';
        ctx.beginPath();
        ctx.arc(f.size * 0.4, -f.size * 0.1, f.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(f.size * 0.45, -f.size * 0.15, f.size * 0.07, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'bird': {
        const wingFlap = Math.sin(time * 0.01 * speedMult + f.wingPhase);
        const wingAngle = wingFlap * 0.6;
        const dir = f.vx > 0 ? 1 : -1;
        ctx.translate(f.x, f.y);
        ctx.scale(dir, 1);
        ctx.fillStyle = color;
        // Body
        ctx.beginPath();
        ctx.ellipse(0, 0, f.size, f.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Wings
        ctx.save();
        ctx.rotate(wingAngle);
        ctx.beginPath();
        ctx.ellipse(-f.size * 0.2, -f.size * 0.3, f.size * 0.8, f.size * 0.25, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.rotate(-wingAngle);
        ctx.beginPath();
        ctx.ellipse(-f.size * 0.2, f.size * 0.3, f.size * 0.8, f.size * 0.25, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        // Beak
        ctx.fillStyle = '#ffaa33';
        ctx.beginPath();
        ctx.moveTo(f.size, 0);
        ctx.lineTo(f.size * 1.4, -f.size * 0.1);
        ctx.lineTo(f.size * 1.4, f.size * 0.1);
        ctx.closePath();
        ctx.fill();
        // Eye
        ctx.fillStyle = '#1a1a2e';
        ctx.beginPath();
        ctx.arc(f.size * 0.5, -f.size * 0.1, f.size * 0.12, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'butterfly': {
        const wingOpen = (Math.sin(time * 0.012 * speedMult + f.wingPhase) * 0.5 + 0.5);
        ctx.translate(f.x, f.y);
        ctx.fillStyle = color;
        // Wings — scale Y by wingOpen for flapping effect
        ctx.save();
        ctx.scale(1, 0.3 + wingOpen * 0.7);
        // Upper wings
        ctx.beginPath();
        ctx.ellipse(-f.size * 0.5, -f.size * 0.3, f.size * 0.7, f.size * 0.6, -0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(f.size * 0.5, -f.size * 0.3, f.size * 0.7, f.size * 0.6, 0.3, 0, Math.PI * 2);
        ctx.fill();
        // Lower wings
        ctx.beginPath();
        ctx.ellipse(-f.size * 0.4, f.size * 0.3, f.size * 0.5, f.size * 0.45, -0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(f.size * 0.4, f.size * 0.3, f.size * 0.5, f.size * 0.45, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        // Body
        ctx.fillStyle = '#1a1a2e';
        ctx.beginPath();
        ctx.ellipse(0, 0, f.size * 0.12, f.size * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
    }
    ctx.restore();
  }

  function updateFriend(f, time, dt) {
    const speedMult = 1 - lullabyAmount * 0.7;
    f.x += f.vx * speedMult;

    if (f.type === 'bird') {
      f.y += Math.sin(time * 0.001 + f.swoopPhase) * 0.3 * speedMult;
    } else if (f.type === 'butterfly') {
      f.x += Math.sin(time * 0.002 + f.flutterPhase) * 0.5 * speedMult;
      f.y += f.vy * speedMult + Math.cos(time * 0.0015 + f.flutterPhase) * 0.3 * speedMult;
    } else {
      f.y += f.vy * speedMult + Math.sin(time * 0.001) * 0.2 * speedMult;
    }

    // Wrap around
    const pad = f.size * 2;
    if (f.vx > 0 && f.x > W() + pad) f.x = -pad;
    if (f.vx < 0 && f.x < -pad) f.x = W() + pad;
    if (f.y < -pad) f.y = H() + pad;
    if (f.y > H() + pad) f.y = -pad;
  }

  // ==============================================
  // Floating Bubbles (from v4)
  // ==============================================
  const bubbles = [];
  const MAX_BUBBLES = 15;
  let bubbleSpawnTimer = 0;

  function createBubble(x, y, size) {
    return { x: x !== undefined ? x : Math.random() * W(), y: y !== undefined ? y : H() + (size || 40),
      size: size || 20 + Math.random() * 40, vy: -(0.3 + Math.random() * 0.5),
      vx: (Math.random() - 0.5) * 0.3, wobblePhase: Math.random() * Math.PI * 2,
      wobbleSpeed: 0.002 + Math.random() * 0.002, wobbleAmp: 15 + Math.random() * 20,
      alpha: 0.3 + Math.random() * 0.3, life: 1.0, popping: false, popProgress: 0 };
  }

  function drawBubble(b, time) {
    if (b.popping) {
      ctx.save(); ctx.globalAlpha = (1 - b.popProgress) * 0.5;
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath();
      ctx.arc(b.x, b.y, b.size * (1 + b.popProgress * 1.5), 0, Math.PI * 2);
      ctx.stroke(); ctx.restore(); return;
    }
    const wobbleX = Math.sin(time * b.wobbleSpeed + b.wobblePhase) * b.wobbleAmp;
    const drawX = b.x + wobbleX;
    ctx.save(); ctx.globalAlpha = b.alpha * (1 - lullabyAmount * 0.3);
    const grad = ctx.createRadialGradient(drawX - b.size * 0.25, b.y - b.size * 0.25, b.size * 0.1, drawX, b.y, b.size);
    grad.addColorStop(0, 'rgba(200,220,255,0.4)'); grad.addColorStop(0.5, 'rgba(150,180,255,0.15)'); grad.addColorStop(1, 'rgba(100,140,255,0.05)');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(drawX, b.y, b.size, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = 'rgba(200,220,255,0.3)'; ctx.lineWidth = 1.5; ctx.stroke();
    ctx.globalAlpha = b.alpha * 0.8;
    const hlGrad = ctx.createRadialGradient(drawX - b.size * 0.3, b.y - b.size * 0.3, 0, drawX - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.4);
    hlGrad.addColorStop(0, 'rgba(255,255,255,0.6)'); hlGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = hlGrad; ctx.beginPath(); ctx.arc(drawX - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.35, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    b.drawX = drawX;
  }

  function popBubble(b) {
    b.popping = true; b.popProgress = 0;
    playPopSound(400 + (1 / Math.max(b.size, 1)) * 8000);
    if (b.size > 18) {
      const childCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < childCount; i++) {
        const angle = (Math.PI * 2 * i) / childCount + Math.random() * 0.5;
        const childSize = b.size * (0.3 + Math.random() * 0.2);
        const child = createBubble(b.drawX || b.x, b.y, childSize);
        child.vx = Math.cos(angle) * 1 + (Math.random() - 0.5) * 0.5;
        child.vy = Math.sin(angle) * 0.8 - 0.5;
        bubbles.push(child);
      }
    }
  }

  // ==============================================
  // V5 FEATURE 3: Cause & Effect Zones
  // ==============================================
  // Zone effects — each spawns unique visuals
  const zoneParticles = [];

  function getZone(x, y) {
    const w = W(), h = H();
    const margin = 0.25; // 25% from each edge
    if (y < h * margin) return 'top';
    if (y > h * (1 - margin)) return 'bottom';
    if (x < w * margin) return 'left';
    if (x > w * (1 - margin)) return 'right';
    return 'center';
  }

  function spawnZoneEffect(x, y, zone, time) {
    const color = getRandomFromPalette(time);
    switch(zone) {
      case 'top':
        // Rain down sparkles
        for (let i = 0; i < 20; i++) {
          zoneParticles.push({
            type: 'sparkle',
            x: x + (Math.random() - 0.5) * 150,
            y: y - 20,
            vx: (Math.random() - 0.5) * 0.5,
            vy: 1 + Math.random() * 2,
            size: 2 + Math.random() * 4,
            life: 1.0,
            decay: 0.005 + Math.random() * 0.008,
            color,
            twinklePhase: Math.random() * Math.PI * 2,
          });
        }
        break;

      case 'bottom':
        // Bloom flowers upward
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 * i) / 8;
          zoneParticles.push({
            type: 'flower',
            x: x + Math.cos(angle) * 20,
            y: y,
            vx: Math.cos(angle) * 0.3,
            vy: -(1 + Math.random() * 2),
            size: 6 + Math.random() * 8,
            life: 1.0,
            decay: 0.004 + Math.random() * 0.004,
            color,
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 0.05,
            petalCount: 5 + Math.floor(Math.random() * 3),
          });
        }
        break;

      case 'left':
      case 'right':
        // Horizontal wave
        const dir = zone === 'left' ? 1 : -1;
        for (let i = 0; i < 12; i++) {
          zoneParticles.push({
            type: 'wave',
            x: x,
            y: y + (Math.random() - 0.5) * 100,
            vx: dir * (2 + Math.random() * 2),
            vy: (Math.random() - 0.5) * 0.5,
            size: 4 + Math.random() * 8,
            life: 1.0,
            decay: 0.006 + Math.random() * 0.006,
            color,
            wavePhase: Math.random() * Math.PI * 2,
          });
        }
        break;
    }
  }

  function drawZoneParticle(p, time) {
    ctx.save();
    switch(p.type) {
      case 'sparkle': {
        const twinkle = Math.sin(time * 0.01 + p.twinklePhase) * 0.5 + 0.5;
        ctx.globalAlpha = p.life * twinkle;
        ctx.fillStyle = p.color;
        // 4-pointed star sparkle
        ctx.translate(p.x, p.y);
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
          const a = (Math.PI * 2 * i) / 8;
          const r = i % 2 === 0 ? p.size : p.size * 0.3;
          if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
          else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
        }
        ctx.closePath();
        ctx.fill();
        break;
      }
      case 'flower': {
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = p.color;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        // Draw petals
        for (let i = 0; i < p.petalCount; i++) {
          const a = (Math.PI * 2 * i) / p.petalCount;
          ctx.save();
          ctx.rotate(a);
          ctx.beginPath();
          ctx.ellipse(p.size * 0.6, 0, p.size * 0.5, p.size * 0.25, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        // Center
        ctx.fillStyle = '#ffee77';
        ctx.beginPath();
        ctx.arc(0, 0, p.size * 0.25, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
      case 'wave': {
        const waveY = Math.sin(time * 0.005 + p.wavePhase) * 15;
        ctx.globalAlpha = p.life * 0.6;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y + waveY, p.size * p.life, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
    }
    ctx.restore();
  }

  // ==============================================
  // Reactive Face (from v4)
  // ==============================================
  let faceState = 'idle';
  let faceStateTimer = 0;
  let faceTargetX = 0, faceTargetY = 0;
  let faceLookX = 0, faceLookY = 0;
  let eyeScaleY = 1;
  let blinkTimer = 0, nextBlink = 3000 + Math.random() * 3000;
  let expressionTimer = 0, nextExpression = 8000 + Math.random() * 10000;

  function setFaceSurprised() { faceState = 'surprised'; faceStateTimer = 800; }

  function setFaceLooking(tapX, tapY) {
    const dx = tapX - W() / 2, dy = tapY - H() / 2;
    if (Math.sqrt(dx * dx + dy * dy) < 120) { setFaceSurprised(); return; }
    faceTargetX = Math.max(-1, Math.min(1, dx / (W() * 0.4)));
    faceTargetY = Math.max(-1, Math.min(1, dy / (H() * 0.4)));
    faceState = 'looking'; faceStateTimer = 2000;
  }

  function updateFace(dt) {
    blinkTimer += dt;
    if (blinkTimer > nextBlink) { blinkTimer = 0; nextBlink = 3000 + Math.random() * 3000; eyeScaleY = 0.05; setTimeout(() => { eyeScaleY = 1; }, 120); }

    expressionTimer += dt;
    if (expressionTimer > nextExpression && faceState === 'idle') {
      expressionTimer = 0; nextExpression = 8000 + Math.random() * 10000;
      // In lullaby mode, face is always sleepy
      if (lullabyAmount > 0.5) { faceState = 'sleepy'; faceStateTimer = 3000; }
      else { faceState = ['happy', 'sleepy'][Math.floor(Math.random() * 2)]; faceStateTimer = 2000 + Math.random() * 1000; }
    }

    if (faceStateTimer > 0) { faceStateTimer -= dt; if (faceStateTimer <= 0) { faceState = lullabyAmount > 0.5 ? 'sleepy' : 'idle'; faceTargetX = 0; faceTargetY = 0; } }

    faceLookX += (faceTargetX - faceLookX) * 0.08;
    faceLookY += (faceTargetY - faceLookY) * 0.08;
    const pupilOffsetX = faceLookX * 6, pupilOffsetY = faceLookY * 5;
    pupilL.setAttribute('cx', 74 + pupilOffsetX); pupilL.setAttribute('cy', 78 + pupilOffsetY);
    pupilR.setAttribute('cx', 134 + pupilOffsetX); pupilR.setAttribute('cy', 78 + pupilOffsetY);

    let eyeRY = 18 * eyeScaleY, mouthPath;
    switch (faceState) {
      case 'surprised':
        eyeRY = 22 * eyeScaleY; eyeL.setAttribute('rx', '18'); eyeR.setAttribute('rx', '18');
        mouthPath = 'M 85 118 Q 100 140 115 118 Q 100 145 85 118';
        mouth.setAttribute('fill', '#1a1a2e'); mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.7'); cheekR.setAttribute('opacity', '0.7'); break;
      case 'happy':
        eyeRY = 12 * eyeScaleY; eyeL.setAttribute('rx', '16'); eyeR.setAttribute('rx', '16');
        mouthPath = 'M 65 118 Q 100 158 135 118';
        mouth.setAttribute('fill', 'none'); mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.8'); cheekR.setAttribute('opacity', '0.8'); break;
      case 'sleepy':
        eyeRY = (lullabyAmount > 0.5 ? 5 : 8) * eyeScaleY;
        eyeL.setAttribute('rx', '16'); eyeR.setAttribute('rx', '16');
        mouthPath = 'M 75 122 Q 100 140 125 122';
        mouth.setAttribute('fill', 'none'); mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.4'); cheekR.setAttribute('opacity', '0.4'); break;
      default:
        eyeRY = 18 * eyeScaleY; eyeL.setAttribute('rx', '16'); eyeR.setAttribute('rx', '16');
        mouthPath = 'M 70 120 Q 100 150 130 120';
        mouth.setAttribute('fill', 'none'); mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.5'); cheekR.setAttribute('opacity', '0.5'); break;
    }
    eyeL.setAttribute('ry', eyeRY); eyeR.setAttribute('ry', eyeRY); mouth.setAttribute('d', mouthPath);
  }

  // --- Helper draws ---
  function drawStar(cx, cy, r, points, rotation) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) { const angle = (i * Math.PI / points) + rotation; const rad = i % 2 === 0 ? r : r * 0.45; if (i === 0) ctx.moveTo(cx + Math.cos(angle) * rad, cy + Math.sin(angle) * rad); else ctx.lineTo(cx + Math.cos(angle) * rad, cy + Math.sin(angle) * rad); }
    ctx.closePath();
  }

  function drawSimpleShape(s, time) {
    ctx.save(); ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + (s.phase || 0)));
    ctx.fillStyle = s.color || '#fff'; ctx.strokeStyle = s.color || '#fff'; ctx.lineWidth = 3;
    const ds = s.size || 20;
    switch (s.type) { case 'circle': ctx.beginPath(); ctx.arc(s.x, s.y, ds, 0, Math.PI * 2); ctx.fill(); break;
      case 'star': drawStar(s.x, s.y, ds, 5, s.rotation || 0); ctx.fill(); break;
      case 'roundedRect': { const half = ds * 0.8; const r = ds * 0.25; ctx.translate(s.x, s.y); ctx.rotate(s.rotation || 0); ctx.beginPath(); ctx.moveTo(-half + r, -half); ctx.lineTo(half - r, -half); ctx.quadraticCurveTo(half, -half, half, -half + r); ctx.lineTo(half, half - r); ctx.quadraticCurveTo(half, half, half - r, half); ctx.lineTo(-half + r, half); ctx.quadraticCurveTo(-half, half, -half, half - r); ctx.lineTo(-half, -half + r); ctx.quadraticCurveTo(-half, -half, -half + r, -half); ctx.closePath(); ctx.fill(); break; }
      case 'ring': ctx.beginPath(); ctx.arc(s.x, s.y, ds, 0, Math.PI * 2); ctx.stroke(); break; }
    ctx.restore();
  }

  // --- Standard effects ---
  const particles = [];
  const ripples = [];
  const bloomShapes = [];
  const glows = [];
  const trailParticles = [];
  let lastDragPos = null;

  function spawnParticles(x, y, count, time) { const color = getRandomFromPalette(time); for (let i = 0; i < count; i++) { const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3; const speed = 1.5 + Math.random() * 3; particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: 4 + Math.random() * 12, life: 1.0, decay: 0.008 + Math.random() * 0.012, color, type: Math.random() > 0.5 ? 'circle' : 'star', rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.1 }); } }
  function spawnRipple(x, y, time) { for (let r = 0; r < 3; r++) ripples.push({ x, y, radius: 5 + r * 8, maxRadius: 100 + Math.random() * 80 + r * 30, alpha: 0.5 - r * 0.12, color: getRandomFromPalette(time) }); }
  function spawnBloomShapes(x, y, time) { const c = 3 + Math.floor(Math.random() * 3); for (let i = 0; i < c; i++) { const a = (Math.PI * 2 * i) / c; const s = 0.5 + Math.random() * 1.5; bloomShapes.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, size: 15 + Math.random() * 30, life: 1.0, decay: 0.006 + Math.random() * 0.006, color: getRandomFromPalette(time), type: ['circle', 'star', 'roundedRect'][Math.floor(Math.random() * 3)], rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.03, alpha: 0.8 }); } }
  function spawnGlow(x, y, time) { glows.push({ x, y, radius: 20, maxRadius: 120, alpha: 0.4, color: getRandomFromPalette(time) }); }
  function spawnTrailParticle(x, y, time) { trailParticles.push({ x, y, size: 3 + Math.random() * 8, life: 1.0, decay: 0.015 + Math.random() * 0.01, color: getRandomFromPalette(time), vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5 }); }

  function pushNearbyShapes(x, y) { for (const s of shapes) { const dx = s.x - x, dy = s.y - y, dist = Math.sqrt(dx * dx + dy * dy); if (dist < 200 && dist > 0) { const force = (1 - dist / 200) * 3; s.pushVx += (dx / dist) * force; s.pushVy += (dy / dist) * force; s.sizePulseAmp = Math.min(s.sizePulseAmp + 3, 25); } } }

  let heartbeatPhase = 0;

  function checkBubbleTap(x, y) { for (let i = bubbles.length - 1; i >= 0; i--) { const b = bubbles[i]; if (b.popping) continue; const bx = b.drawX || b.x, dx = x - bx, dy = y - b.y; if (Math.sqrt(dx * dx + dy * dy) < b.size * 1.2) { popBubble(b); return true; } } return false; }

  // --- Interaction ---
  function handleInteraction(x, y, time) {
    initAudio();
    lastInteractionTime = time;

    const hitBubble = checkBubbleTap(x, y);

    // Zone-specific effects
    const zone = getZone(x, y);
    if (zone !== 'center') {
      spawnZoneEffect(x, y, zone, time);
      playZoneSound(zone);
    } else if (!hitBubble) {
      playChord();
    }

    spawnParticles(x, y, 14, time);
    spawnRipple(x, y, time);
    spawnBloomShapes(x, y, time);
    spawnGlow(x, y, time);
    pushNearbyShapes(x, y);
    setFaceLooking(x, y);
  }

  // --- Touch/Pointer events ---
  let usingTouch = false;

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); usingTouch = true;
    const now = performance.now();
    for (let i = 0; i < e.changedTouches.length; i++) { const t = e.changedTouches[i]; handleInteraction(t.clientX, t.clientY, now); }
    if (e.changedTouches.length > 0) { const t = e.changedTouches[0]; lastDragPos = { x: t.clientX, y: t.clientY }; }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); const now = performance.now();
    for (let i = 0; i < e.changedTouches.length; i++) { const t = e.changedTouches[i]; spawnTrailParticle(t.clientX, t.clientY, now); }
  }, { passive: false });

  canvas.addEventListener('touchend', () => { lastDragPos = null; });

  canvas.addEventListener('pointerdown', (e) => {
    if (usingTouch) return; e.preventDefault();
    handleInteraction(e.clientX, e.clientY, performance.now());
    lastDragPos = { x: e.clientX, y: e.clientY };
  });

  canvas.addEventListener('pointermove', (e) => {
    if (usingTouch) return;
    if (e.buttons > 0) { const now = performance.now(); if (lastDragPos) { const dx = e.clientX - lastDragPos.x, dy = e.clientY - lastDragPos.y; if (Math.sqrt(dx * dx + dy * dy) > 5) { spawnTrailParticle(e.clientX, e.clientY, now); lastDragPos = { x: e.clientX, y: e.clientY }; } } else { lastDragPos = { x: e.clientX, y: e.clientY }; } }
  });

  canvas.addEventListener('pointerup', () => { if (!usingTouch) lastDragPos = null; });

  // --- Main Loop ---
  let lastTime = 0;

  function frame(time) {
    const dt = lastTime ? time - lastTime : 16;
    lastTime = time;
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    const w = W(), h = H();

    // Update lullaby
    updateLullaby(time);

    // Background — shifts to deeper blue in lullaby
    heartbeatPhase += 0.015;
    const pulse = Math.sin(heartbeatPhase) * 0.5 + 0.5;
    const bgBright = (8 + pulse * 6) * (1 - lullabyAmount * 0.5);
    const bgBlue = bgBright + 4 + lullabyAmount * 8;
    ctx.fillStyle = `rgb(${bgBright}, ${bgBright}, ${bgBlue})`;
    ctx.fillRect(0, 0, w, h);

    drawStars(time);

    // Morphing shapes
    for (const s of shapes) { updateShape(s, time, dt); drawMorphedShape(s, time); }

    // Shape friends
    for (const f of friends) { updateFriend(f, time, dt); drawFriend(f, time); }

    // Bubbles
    bubbleSpawnTimer += dt;
    if (bubbleSpawnTimer > 3000 && bubbles.length < MAX_BUBBLES) { bubbleSpawnTimer = 0; bubbles.push(createBubble()); }
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      if (b.popping) { b.popProgress += 0.04; if (b.popProgress >= 1) { bubbles.splice(i, 1); continue; } drawBubble(b, time); continue; }
      b.y += b.vy * (1 - lullabyAmount * 0.5); b.x += b.vx;
      if (b.y < -b.size * 2) { bubbles.splice(i, 1); continue; }
      drawBubble(b, time);
    }

    // Zone particles
    for (let i = zoneParticles.length - 1; i >= 0; i--) {
      const p = zoneParticles[i];
      p.x += (p.vx || 0); p.y += (p.vy || 0);
      if (p.rotSpeed) p.rotation += p.rotSpeed;
      p.life -= p.decay;
      if (p.life <= 0) { zoneParticles.splice(i, 1); continue; }
      drawZoneParticle(p, time);
    }

    // Glows
    for (let i = glows.length - 1; i >= 0; i--) { const g = glows[i]; g.radius += 1.5; g.alpha -= 0.005; if (g.alpha <= 0 || g.radius >= g.maxRadius) { glows.splice(i, 1); continue; } ctx.save(); const gr = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.radius); gr.addColorStop(0, g.color); gr.addColorStop(1, 'transparent'); ctx.globalAlpha = g.alpha; ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }

    // Ripples
    for (let i = ripples.length - 1; i >= 0; i--) { const r = ripples[i]; r.radius += 1.8; r.alpha -= 0.008; if (r.alpha <= 0 || r.radius >= r.maxRadius) { ripples.splice(i, 1); continue; } ctx.save(); ctx.globalAlpha = r.alpha; ctx.strokeStyle = r.color; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); }

    // Bloom shapes
    for (let i = bloomShapes.length - 1; i >= 0; i--) { const b = bloomShapes[i]; b.x += b.vx; b.y += b.vy; b.vx *= 0.99; b.vy *= 0.99; b.rotation += b.rotSpeed; b.life -= b.decay; if (b.life <= 0) { bloomShapes.splice(i, 1); continue; } drawSimpleShape({ ...b, alpha: b.life * b.alpha, size: b.size }, time); }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; p.vy += 0.02; p.life -= p.decay; p.rotation += p.rotSpeed; if (p.life <= 0) { particles.splice(i, 1); continue; } ctx.save(); ctx.globalAlpha = p.life; ctx.fillStyle = p.color; if (p.type === 'circle') { ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill(); } else { drawStar(p.x, p.y, p.size * p.life, 5, p.rotation); ctx.fill(); } ctx.restore(); }

    // Trail particles
    for (let i = trailParticles.length - 1; i >= 0; i--) { const tp = trailParticles[i]; tp.x += tp.vx; tp.y += tp.vy; tp.life -= tp.decay; if (tp.life <= 0) { trailParticles.splice(i, 1); continue; } ctx.save(); ctx.globalAlpha = tp.life * 0.7; const gr = ctx.createRadialGradient(tp.x, tp.y, 0, tp.x, tp.y, tp.size * tp.life); gr.addColorStop(0, tp.color); gr.addColorStop(1, 'transparent'); ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(tp.x, tp.y, tp.size * tp.life, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }

    updateFace(dt);
    requestAnimationFrame(frame);
  }

  resize();
  requestAnimationFrame(frame);

  let hasRequestedFullscreen = false;
  document.addEventListener('click', () => {
    if (hasRequestedFullscreen) return; hasRequestedFullscreen = true;
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  }, { once: false });

})();
</script>
</body>
</html>
