<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Baby World v4</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a0f;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: default;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }
  /* ==============================================
     V4: Reactive Face (SVG driven by JS)
     ============================================== */
  #face {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 180px; height: 180px;
    pointer-events: none;
    z-index: 10;
    animation: breathe 4s ease-in-out infinite;
    transition: width 0.3s, height 0.3s;
  }
  @keyframes breathe {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
  }
</style>
</head>
<body>

<!-- V4: Reactive face — eyes and mouth are controlled by JS -->
<svg id="face" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- Face circle -->
  <circle cx="100" cy="100" r="90" fill="#fff" stroke="#e0e0e0" stroke-width="2"/>
  <!-- Left eye -->
  <ellipse id="eyeL" cx="70" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
  <ellipse id="pupilL" cx="74" cy="78" rx="6" ry="7" fill="#fff"/>
  <!-- Right eye -->
  <ellipse id="eyeR" cx="130" cy="82" rx="16" ry="18" fill="#1a1a2e"/>
  <ellipse id="pupilR" cx="134" cy="78" rx="6" ry="7" fill="#fff"/>
  <!-- Rosy cheeks -->
  <ellipse id="cheekL" cx="50" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <ellipse id="cheekR" cx="150" cy="110" rx="18" ry="12" fill="#ffb3b3" opacity="0.5"/>
  <!-- Mouth -->
  <path id="mouth" d="M 70 120 Q 100 150 130 120" stroke="#1a1a2e" stroke-width="4" fill="none" stroke-linecap="round"/>
</svg>

<canvas id="canvas"></canvas>

<script>
(function() {
  'use strict';

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // --- Face elements ---
  const eyeL = document.getElementById('eyeL');
  const eyeR = document.getElementById('eyeR');
  const pupilL = document.getElementById('pupilL');
  const pupilR = document.getElementById('pupilR');
  const cheekL = document.getElementById('cheekL');
  const cheekR = document.getElementById('cheekR');
  const mouth = document.getElementById('mouth');
  const faceSvg = document.getElementById('face');

  // --- Resize ---
  function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
    initStars();
  }
  window.addEventListener('resize', resize);

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  // ==============================================
  // Twinkling Star Field (from v3)
  // ==============================================
  const stars = [];
  const STAR_COUNT = 80;

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({
        x: Math.random() * W(),
        y: Math.random() * H(),
        baseSize: 0.5 + Math.random() * 2,
        twinkleSpeed: 0.001 + Math.random() * 0.003,
        twinklePhase: Math.random() * Math.PI * 2,
        baseAlpha: 0.2 + Math.random() * 0.5,
      });
    }
  }

  function drawStars(time) {
    for (const star of stars) {
      const twinkle = Math.sin(time * star.twinkleSpeed + star.twinklePhase);
      const alpha = star.baseAlpha * (0.3 + 0.7 * (twinkle * 0.5 + 0.5));
      const size = star.baseSize * (0.8 + 0.4 * (twinkle * 0.5 + 0.5));
      ctx.save();
      ctx.globalAlpha = alpha;
      const gradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, size * 3);
      gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(0.4, 'rgba(200,210,255,0.3)');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(star.x, star.y, size * 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ==============================================
  // Color Evolution (from v2)
  // ==============================================
  const colorPhases = [
    ['#ffffff', '#e0e0e0', '#c0c0c0', '#d0d0d0', '#f5f5f5'],
    ['#ffffff', '#e0e0e0', '#ff4444', '#ff6b6b', '#ffaaaa'],
    ['#ffffff', '#ff4444', '#4488ff', '#66aaff', '#aaccff'],
    ['#ff4444', '#ff6b6b', '#ffdd44', '#ffee77', '#ffaa33'],
    ['#4488ff', '#66aaff', '#44dd88', '#77eebb', '#88ddff'],
    ['#ff4444', '#ffdd44', '#44dd88', '#4488ff', '#cc66ff'],
  ];

  const PHASE_DURATION = 45000;
  let colorPhaseStart = performance.now();

  function lerpColor(a, b, t) {
    const ah = parseInt(a.slice(1), 16);
    const bh = parseInt(b.slice(1), 16);
    const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    return `rgb(${Math.round(ar + (br - ar) * t)},${Math.round(ag + (bg - ag) * t)},${Math.round(ab + (bb - ab) * t)})`;
  }

  function getCurrentPalette(time) {
    const elapsed = time - colorPhaseStart;
    const totalCycle = PHASE_DURATION * colorPhases.length;
    const cycleTime = elapsed % totalCycle;
    const phaseIndex = Math.floor(cycleTime / PHASE_DURATION);
    const nextPhaseIndex = (phaseIndex + 1) % colorPhases.length;
    const phaseProgress = (cycleTime % PHASE_DURATION) / PHASE_DURATION;
    const transitionZone = 0.2;
    const currentPhase = colorPhases[phaseIndex];
    const nextPhase = colorPhases[nextPhaseIndex];
    if (phaseProgress > 1 - transitionZone) {
      const t = (phaseProgress - (1 - transitionZone)) / transitionZone;
      const smoothT = t * t * (3 - 2 * t);
      return currentPhase.map((c, i) => lerpColor(c, nextPhase[i], smoothT));
    }
    return currentPhase;
  }

  function getRandomFromPalette(time) {
    const pal = getCurrentPalette(time);
    return pal[Math.floor(Math.random() * pal.length)];
  }

  // ==============================================
  // Sound Engine + V4: Ambient Soundscape
  // ==============================================
  let audioCtx = null;
  let ambientStarted = false;
  let ambientGain = null;
  let ambientOsc1 = null;
  let ambientOsc2 = null;

  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function startAmbientSoundscape() {
    if (ambientStarted || !audioCtx) return;
    ambientStarted = true;

    // Master gain for ambient layer
    ambientGain = audioCtx.createGain();
    ambientGain.gain.setValueAtTime(0, audioCtx.currentTime);
    // Fade in over 3 seconds
    ambientGain.gain.linearRampToValueAtTime(0.04, audioCtx.currentTime + 3);
    ambientGain.connect(audioCtx.destination);

    // Warm drone — low C2 (65Hz)
    ambientOsc1 = audioCtx.createOscillator();
    ambientOsc1.type = 'sine';
    ambientOsc1.frequency.setValueAtTime(65.41, audioCtx.currentTime);
    const gain1 = audioCtx.createGain();
    gain1.gain.setValueAtTime(1.0, audioCtx.currentTime);
    ambientOsc1.connect(gain1);
    gain1.connect(ambientGain);
    ambientOsc1.start();

    // Gentle fifth above — G2 (98Hz)
    ambientOsc2 = audioCtx.createOscillator();
    ambientOsc2.type = 'sine';
    ambientOsc2.frequency.setValueAtTime(98.00, audioCtx.currentTime);
    const gain2 = audioCtx.createGain();
    gain2.gain.setValueAtTime(0.5, audioCtx.currentTime);
    ambientOsc2.connect(gain2);
    gain2.connect(ambientGain);
    ambientOsc2.start();

    // Slowly modulate the drone pitch over time for organic feel
    function modulateAmbient() {
      if (!audioCtx || !ambientOsc1) return;
      const now = audioCtx.currentTime;
      // Gentle pitch drift on the drone
      const drift = Math.sin(now * 0.05) * 2;
      ambientOsc1.frequency.setTargetAtTime(65.41 + drift, now, 0.5);
      ambientOsc2.frequency.setTargetAtTime(98.00 + drift * 0.7, now, 0.5);
      setTimeout(modulateAmbient, 500);
    }
    modulateAmbient();
  }

  const pentatonic = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25];
  let noteIndex = 0;

  function playChord() {
    if (!audioCtx) return;
    const baseIdx = noteIndex % pentatonic.length;
    const intervals = [2, 4];
    const interval = intervals[Math.floor(Math.random() * intervals.length)];
    const freqs = [
      pentatonic[baseIdx],
      pentatonic[(baseIdx + interval) % pentatonic.length],
    ];
    noteIndex++;

    freqs.forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = i === 0 ? 'sine' : 'triangle';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      const vol = i === 0 ? 0.12 : 0.06;
      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.05);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 1.6);
    });
  }

  // Soft pop sound for bubbles
  function playPopSound(pitch) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(pitch || 600, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(audioCtx.currentTime);
    osc.stop(audioCtx.currentTime + 0.25);
  }

  // ==============================================
  // Shape Morphing (from v3)
  // ==============================================
  const SHAPE_TYPES = ['circle', 'star', 'roundedRect', 'ring'];

  const shapes = [];
  const SHAPE_COUNT = 10;

  function createShape(x, y) {
    const typeIdx = Math.floor(Math.random() * SHAPE_TYPES.length);
    return {
      baseX: x !== undefined ? x : Math.random() * W(),
      baseY: y !== undefined ? y : Math.random() * H(),
      driftVx: (Math.random() - 0.5) * 0.15,
      driftVy: (Math.random() - 0.5) * 0.15,
      amplitudeX: 30 + Math.random() * 80,
      amplitudeY: 20 + Math.random() * 60,
      frequencyX: 0.0003 + Math.random() * 0.0006,
      frequencyY: 0.0004 + Math.random() * 0.0005,
      phaseX: Math.random() * Math.PI * 2,
      phaseY: Math.random() * Math.PI * 2,
      baseSize: 30 + Math.random() * 60,
      sizePulseAmp: 5 + Math.random() * 10,
      sizePulseFreq: 0.0008 + Math.random() * 0.001,
      sizePulsePhase: Math.random() * Math.PI * 2,
      x: 0, y: 0, size: 0,
      rotation: Math.random() * Math.PI * 2,
      rotSpeed: (Math.random() - 0.5) * 0.005,
      morphFrom: typeIdx,
      morphTo: typeIdx,
      morphProgress: 1.0,
      morphSpeed: 0.0003 + Math.random() * 0.0003,
      morphTimer: 8000 + Math.random() * 15000,
      morphCountdown: 8000 + Math.random() * 15000,
      colorIndex: Math.floor(Math.random() * 5),
      alpha: 0.6 + Math.random() * 0.4,
      phase: Math.random() * Math.PI * 2,
      pushVx: 0,
      pushVy: 0,
    };
  }

  for (let i = 0; i < SHAPE_COUNT; i++) {
    shapes.push(createShape());
  }

  function getShapePoints(type, cx, cy, size, rotation, numPoints) {
    const points = [];
    numPoints = numPoints || 32;
    switch (type) {
      case 0:
        for (let i = 0; i < numPoints; i++) {
          const a = (Math.PI * 2 * i) / numPoints + rotation;
          points.push({ x: cx + Math.cos(a) * size, y: cy + Math.sin(a) * size });
        }
        break;
      case 1:
        for (let i = 0; i < numPoints; i++) {
          const a = (Math.PI * 2 * i) / numPoints + rotation;
          const starPhase = (i / numPoints) * 5;
          const r = size * (0.725 + 0.275 * Math.cos(starPhase * Math.PI * 2));
          points.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
        }
        break;
      case 2: {
        const half = size * 0.8;
        const corner = size * 0.25;
        for (let i = 0; i < numPoints; i++) {
          const t = i / numPoints;
          let px, py;
          const segLen = (half - corner) * 2;
          const cornerLen = Math.PI * corner / 2;
          let d = t * (segLen * 4 + cornerLen * 4);
          if (d < segLen) { px = -half + corner + d; py = -half; }
          else if ((d -= segLen) < cornerLen) { const a = -Math.PI/2 + (d/cornerLen) * (Math.PI/2); px = half - corner + Math.cos(a) * corner; py = -half + corner + Math.sin(a) * corner; }
          else if ((d -= cornerLen) < segLen) { px = half; py = -half + corner + d; }
          else if ((d -= segLen) < cornerLen) { const a = 0 + (d/cornerLen) * (Math.PI/2); px = half - corner + Math.cos(a) * corner; py = half - corner + Math.sin(a) * corner; }
          else if ((d -= cornerLen) < segLen) { px = half - corner - d; py = half; }
          else if ((d -= segLen) < cornerLen) { const a = Math.PI/2 + (d/cornerLen) * (Math.PI/2); px = -half + corner + Math.cos(a) * corner; py = half - corner + Math.sin(a) * corner; }
          else if ((d -= cornerLen) < segLen) { px = -half; py = half - corner - d; }
          else { const a = Math.PI + (Math.min(d, cornerLen)/cornerLen) * (Math.PI/2); px = -half + corner + Math.cos(a) * corner; py = -half + corner + Math.sin(a) * corner; }
          const cos = Math.cos(rotation), sin = Math.sin(rotation);
          points.push({ x: cx + px * cos - py * sin, y: cy + px * sin + py * cos });
        }
        break;
      }
      case 3:
        for (let i = 0; i < numPoints; i++) {
          const a = (Math.PI * 2 * i) / numPoints + rotation;
          const wobble = 0.8 + 0.2 * Math.sin(i * 0.5);
          points.push({ x: cx + Math.cos(a) * size * wobble, y: cy + Math.sin(a) * size * wobble });
        }
        break;
    }
    return points;
  }

  function drawMorphedShape(s, time) {
    const numPoints = 48;
    const fromPoints = getShapePoints(s.morphFrom, s.x, s.y, s.size, s.rotation, numPoints);
    const toPoints = getShapePoints(s.morphTo, s.x, s.y, s.size, s.rotation, numPoints);
    const t = s.morphProgress;
    const smooth = t * t * (3 - 2 * t);
    ctx.save();
    ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + s.phase));
    ctx.fillStyle = s.color || '#fff';
    ctx.strokeStyle = s.color || '#fff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < numPoints; i++) {
      const px = fromPoints[i].x + (toPoints[i].x - fromPoints[i].x) * smooth;
      const py = fromPoints[i].y + (toPoints[i].y - fromPoints[i].y) * smooth;
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.closePath();
    const currentType = smooth > 0.5 ? s.morphTo : s.morphFrom;
    if (currentType === 3) ctx.stroke();
    else ctx.fill();
    ctx.restore();
  }

  function updateShape(s, time, dt) {
    s.driftVx *= 0.999;
    s.driftVy *= 0.999;
    s.baseX += s.driftVx + s.pushVx;
    s.baseY += s.driftVy + s.pushVy;
    s.pushVx *= 0.96;
    s.pushVy *= 0.96;
    s.x = s.baseX + Math.sin(time * s.frequencyX + s.phaseX) * s.amplitudeX;
    s.y = s.baseY + Math.cos(time * s.frequencyY + s.phaseY) * s.amplitudeY;
    s.size = s.baseSize + Math.sin(time * s.sizePulseFreq + s.sizePulsePhase) * s.sizePulseAmp;
    s.rotation += s.rotSpeed;
    const pal = getCurrentPalette(time);
    s.color = pal[s.colorIndex % pal.length];
    if (s.morphProgress < 1.0) {
      s.morphProgress = Math.min(1.0, s.morphProgress + s.morphSpeed * (dt || 16));
    } else {
      s.morphCountdown -= (dt || 16);
      if (s.morphCountdown <= 0) {
        s.morphFrom = s.morphTo;
        let newType;
        do { newType = Math.floor(Math.random() * SHAPE_TYPES.length); } while (newType === s.morphFrom);
        s.morphTo = newType;
        s.morphProgress = 0;
        s.morphCountdown = s.morphTimer;
      }
    }
    const pad = s.baseSize + 100;
    if (s.baseX < -pad) s.baseX = W() + pad;
    if (s.baseX > W() + pad) s.baseX = -pad;
    if (s.baseY < -pad) s.baseY = H() + pad;
    if (s.baseY > H() + pad) s.baseY = -pad;
  }

  // ==============================================
  // V4 IMPROVEMENT 2: Floating Bubbles
  // ==============================================
  const bubbles = [];
  const MAX_BUBBLES = 15;
  let bubbleSpawnTimer = 0;

  function createBubble(x, y, size) {
    return {
      x: x !== undefined ? x : Math.random() * W(),
      y: y !== undefined ? y : H() + (size || 40),
      size: size || 20 + Math.random() * 40,
      vy: -(0.3 + Math.random() * 0.5), // float upward
      vx: (Math.random() - 0.5) * 0.3,
      wobblePhase: Math.random() * Math.PI * 2,
      wobbleSpeed: 0.002 + Math.random() * 0.002,
      wobbleAmp: 15 + Math.random() * 20,
      alpha: 0.3 + Math.random() * 0.3,
      life: 1.0,
      popping: false,
      popProgress: 0,
    };
  }

  function drawBubble(b, time) {
    if (b.popping) {
      // Pop animation — expanding ring that fades
      ctx.save();
      ctx.globalAlpha = (1 - b.popProgress) * 0.5;
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size * (1 + b.popProgress * 1.5), 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
      return;
    }

    const wobbleX = Math.sin(time * b.wobbleSpeed + b.wobblePhase) * b.wobbleAmp;
    const drawX = b.x + wobbleX;

    ctx.save();
    ctx.globalAlpha = b.alpha;

    // Bubble body — translucent circle with gradient
    const grad = ctx.createRadialGradient(
      drawX - b.size * 0.25, b.y - b.size * 0.25, b.size * 0.1,
      drawX, b.y, b.size
    );
    grad.addColorStop(0, 'rgba(200, 220, 255, 0.4)');
    grad.addColorStop(0.5, 'rgba(150, 180, 255, 0.15)');
    grad.addColorStop(1, 'rgba(100, 140, 255, 0.05)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(drawX, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();

    // Bubble outline
    ctx.strokeStyle = 'rgba(200, 220, 255, 0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Glossy highlight
    ctx.globalAlpha = b.alpha * 0.8;
    const hlGrad = ctx.createRadialGradient(
      drawX - b.size * 0.3, b.y - b.size * 0.3, 0,
      drawX - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.4
    );
    hlGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
    hlGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = hlGrad;
    ctx.beginPath();
    ctx.arc(drawX - b.size * 0.3, b.y - b.size * 0.3, b.size * 0.35, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Store computed draw position for hit testing
    b.drawX = drawX;
  }

  function popBubble(b, time) {
    b.popping = true;
    b.popProgress = 0;
    playPopSound(400 + (1 / Math.max(b.size, 1)) * 8000); // smaller = higher pitch

    // Spawn 2-3 smaller child bubbles if big enough
    if (b.size > 18) {
      const childCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < childCount; i++) {
        const angle = (Math.PI * 2 * i) / childCount + Math.random() * 0.5;
        const childSize = b.size * (0.3 + Math.random() * 0.2);
        const child = createBubble(b.drawX || b.x, b.y, childSize);
        child.vx = Math.cos(angle) * 1 + (Math.random() - 0.5) * 0.5;
        child.vy = Math.sin(angle) * 0.8 - 0.5;
        bubbles.push(child);
      }
    }
  }

  // ==============================================
  // V4 IMPROVEMENT 3: Reactive Face
  // ==============================================
  // Face state
  let faceState = 'idle'; // idle, surprised, looking, happy, sleepy
  let faceStateTimer = 0;
  let faceTargetX = 0; // normalized -1 to 1
  let faceTargetY = 0;
  let faceLookX = 0; // smoothed
  let faceLookY = 0;
  let eyeScaleY = 1; // for blink
  let blinkTimer = 0;
  let nextBlink = 3000 + Math.random() * 3000;
  let expressionTimer = 0;
  let nextExpression = 8000 + Math.random() * 10000;

  function setFaceSurprised() {
    faceState = 'surprised';
    faceStateTimer = 800;
  }

  function setFaceLooking(tapX, tapY) {
    // Get face center in screen coords
    const faceCenterX = W() / 2;
    const faceCenterY = H() / 2;
    const dx = tapX - faceCenterX;
    const dy = tapY - faceCenterY;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // If tap is near face, do surprised
    if (dist < 120) {
      setFaceSurprised();
      return;
    }

    // Otherwise look toward the tap
    faceTargetX = Math.max(-1, Math.min(1, dx / (W() * 0.4)));
    faceTargetY = Math.max(-1, Math.min(1, dy / (H() * 0.4)));
    faceState = 'looking';
    faceStateTimer = 2000;
  }

  function updateFace(dt) {
    // Blink logic
    blinkTimer += dt;
    if (blinkTimer > nextBlink) {
      blinkTimer = 0;
      nextBlink = 3000 + Math.random() * 3000;
      // Quick blink
      eyeScaleY = 0.05;
      setTimeout(() => { eyeScaleY = 1; }, 120);
    }

    // Random expression timer
    expressionTimer += dt;
    if (expressionTimer > nextExpression && faceState === 'idle') {
      expressionTimer = 0;
      nextExpression = 8000 + Math.random() * 10000;
      const expressions = ['happy', 'sleepy'];
      faceState = expressions[Math.floor(Math.random() * expressions.length)];
      faceStateTimer = 2000 + Math.random() * 1000;
    }

    // State timer
    if (faceStateTimer > 0) {
      faceStateTimer -= dt;
      if (faceStateTimer <= 0) {
        faceState = 'idle';
        faceTargetX = 0;
        faceTargetY = 0;
      }
    }

    // Smooth pupil following
    faceLookX += (faceTargetX - faceLookX) * 0.08;
    faceLookY += (faceTargetY - faceLookY) * 0.08;

    // Apply to SVG elements
    const pupilOffsetX = faceLookX * 6;
    const pupilOffsetY = faceLookY * 5;

    // Pupils
    pupilL.setAttribute('cx', 74 + pupilOffsetX);
    pupilL.setAttribute('cy', 78 + pupilOffsetY);
    pupilR.setAttribute('cx', 134 + pupilOffsetX);
    pupilR.setAttribute('cy', 78 + pupilOffsetY);

    // Eye size based on state
    let eyeRY = 18 * eyeScaleY;
    let mouthPath;

    switch (faceState) {
      case 'surprised':
        // Big round eyes, O mouth
        eyeRY = 22 * eyeScaleY;
        eyeL.setAttribute('rx', '18');
        eyeR.setAttribute('rx', '18');
        mouthPath = 'M 85 118 Q 100 140 115 118 Q 100 145 85 118'; // O shape
        mouth.setAttribute('fill', '#1a1a2e');
        mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.7');
        cheekR.setAttribute('opacity', '0.7');
        break;

      case 'happy':
        // Squinty happy eyes, big smile
        eyeRY = 12 * eyeScaleY;
        eyeL.setAttribute('rx', '16');
        eyeR.setAttribute('rx', '16');
        mouthPath = 'M 65 118 Q 100 158 135 118';
        mouth.setAttribute('fill', 'none');
        mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.8');
        cheekR.setAttribute('opacity', '0.8');
        break;

      case 'sleepy':
        // Half-closed eyes, gentle smile
        eyeRY = 8 * eyeScaleY;
        eyeL.setAttribute('rx', '16');
        eyeR.setAttribute('rx', '16');
        mouthPath = 'M 75 122 Q 100 140 125 122';
        mouth.setAttribute('fill', 'none');
        mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.4');
        cheekR.setAttribute('opacity', '0.4');
        break;

      case 'looking':
      default:
        // Normal eyes, normal smile
        eyeRY = 18 * eyeScaleY;
        eyeL.setAttribute('rx', '16');
        eyeR.setAttribute('rx', '16');
        mouthPath = 'M 70 120 Q 100 150 130 120';
        mouth.setAttribute('fill', 'none');
        mouth.setAttribute('stroke', '#1a1a2e');
        cheekL.setAttribute('opacity', '0.5');
        cheekR.setAttribute('opacity', '0.5');
        break;
    }

    eyeL.setAttribute('ry', eyeRY);
    eyeR.setAttribute('ry', eyeRY);
    mouth.setAttribute('d', mouthPath);
  }

  // --- Simple shape draw for bloom/particles ---
  function drawStar(cx, cy, r, points, rotation) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const angle = (i * Math.PI / points) + rotation;
      const rad = i % 2 === 0 ? r : r * 0.45;
      const sx = cx + Math.cos(angle) * rad;
      const sy = cy + Math.sin(angle) * rad;
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
  }

  function drawSimpleShape(s, time) {
    ctx.save();
    ctx.globalAlpha = s.alpha * (0.7 + 0.3 * Math.sin(time * 0.001 + (s.phase || 0)));
    ctx.fillStyle = s.color || '#fff';
    ctx.strokeStyle = s.color || '#fff';
    ctx.lineWidth = 3;
    const drawSize = s.size || s.baseSize || 20;
    switch (s.type) {
      case 'circle':
        ctx.beginPath(); ctx.arc(s.x, s.y, drawSize, 0, Math.PI * 2); ctx.fill(); break;
      case 'star':
        drawStar(s.x, s.y, drawSize, 5, s.rotation || 0); ctx.fill(); break;
      case 'roundedRect': {
        const half = drawSize * 0.8; const r = drawSize * 0.25;
        ctx.translate(s.x, s.y); ctx.rotate(s.rotation || 0);
        ctx.beginPath();
        ctx.moveTo(-half + r, -half); ctx.lineTo(half - r, -half);
        ctx.quadraticCurveTo(half, -half, half, -half + r); ctx.lineTo(half, half - r);
        ctx.quadraticCurveTo(half, half, half - r, half); ctx.lineTo(-half + r, half);
        ctx.quadraticCurveTo(-half, half, -half, half - r); ctx.lineTo(-half, -half + r);
        ctx.quadraticCurveTo(-half, -half, -half + r, -half);
        ctx.closePath(); ctx.fill(); break;
      }
      case 'ring':
        ctx.beginPath(); ctx.arc(s.x, s.y, drawSize, 0, Math.PI * 2); ctx.stroke(); break;
    }
    ctx.restore();
  }

  // --- Tap Particles ---
  const particles = [];

  function spawnParticles(x, y, count, time) {
    const color = getRandomFromPalette(time);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
      const speed = 1.5 + Math.random() * 3;
      particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
        size: 4 + Math.random() * 12, life: 1.0, decay: 0.008 + Math.random() * 0.012,
        color, type: Math.random() > 0.5 ? 'circle' : 'star',
        rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.1 });
    }
  }

  // --- Tap Ripples ---
  const ripples = [];
  function spawnRipple(x, y, time) {
    for (let r = 0; r < 3; r++) {
      ripples.push({ x, y, radius: 5 + r * 8, maxRadius: 100 + Math.random() * 80 + r * 30,
        alpha: 0.5 - r * 0.12, color: getRandomFromPalette(time) });
    }
  }

  // --- Tap Bloom Shapes ---
  const bloomShapes = [];
  function spawnBloomShapes(x, y, time) {
    const count = 3 + Math.floor(Math.random() * 3);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 0.5 + Math.random() * 1.5;
      bloomShapes.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
        size: 15 + Math.random() * 30, life: 1.0, decay: 0.006 + Math.random() * 0.006,
        color: getRandomFromPalette(time),
        type: ['circle', 'star', 'roundedRect'][Math.floor(Math.random() * 3)],
        rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 0.03, alpha: 0.8 });
    }
  }

  // --- Glows ---
  const glows = [];
  function spawnGlow(x, y, time) {
    glows.push({ x, y, radius: 20, maxRadius: 120, alpha: 0.4, color: getRandomFromPalette(time) });
  }

  // --- Trail Particles ---
  const trailParticles = [];
  let lastDragPos = null;
  function spawnTrailParticle(x, y, time) {
    trailParticles.push({ x, y, size: 3 + Math.random() * 8, life: 1.0,
      decay: 0.015 + Math.random() * 0.01, color: getRandomFromPalette(time),
      vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5 });
  }

  // --- Push nearby shapes ---
  function pushNearbyShapes(x, y) {
    const pushRadius = 200;
    for (const s of shapes) {
      const dx = s.x - x;
      const dy = s.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < pushRadius && dist > 0) {
        const force = (1 - dist / pushRadius) * 3;
        s.pushVx += (dx / dist) * force;
        s.pushVy += (dy / dist) * force;
        s.sizePulseAmp = Math.min(s.sizePulseAmp + 3, 25);
      }
    }
  }

  // --- Heartbeat Pulse ---
  let heartbeatPhase = 0;

  // --- Check if tap hits a bubble ---
  function checkBubbleTap(x, y, time) {
    let hitBubble = false;
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      if (b.popping) continue;
      const bx = b.drawX || b.x;
      const dx = x - bx;
      const dy = y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < b.size * 1.2) {
        popBubble(b, time);
        hitBubble = true;
        break; // only pop one per tap
      }
    }
    return hitBubble;
  }

  // --- Touch/Click Handler ---
  function handleInteraction(x, y, time) {
    initAudio();
    startAmbientSoundscape();

    // Check bubble tap first
    const hitBubble = checkBubbleTap(x, y, time);

    if (!hitBubble) {
      playChord();
    }

    spawnParticles(x, y, 14, time);
    spawnRipple(x, y, time);
    spawnBloomShapes(x, y, time);
    spawnGlow(x, y, time);
    pushNearbyShapes(x, y);

    // Face reacts
    setFaceLooking(x, y);
  }

  canvas.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    handleInteraction(e.clientX, e.clientY, performance.now());
    lastDragPos = { x: e.clientX, y: e.clientY };
  });

  canvas.addEventListener('pointermove', (e) => {
    if (e.buttons > 0 || e.pointerType === 'touch') {
      const now = performance.now();
      if (lastDragPos) {
        const dx = e.clientX - lastDragPos.x;
        const dy = e.clientY - lastDragPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 5) {
          spawnTrailParticle(e.clientX, e.clientY, now);
          lastDragPos = { x: e.clientX, y: e.clientY };
        }
      } else {
        lastDragPos = { x: e.clientX, y: e.clientY };
      }
    }
  });

  canvas.addEventListener('pointerup', () => { lastDragPos = null; });

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const now = performance.now();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const t = e.changedTouches[i];
      handleInteraction(t.clientX, t.clientY, now);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const now = performance.now();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const t = e.changedTouches[i];
      spawnTrailParticle(t.clientX, t.clientY, now);
    }
  }, { passive: false });

  // --- Main Loop ---
  let lastTime = 0;

  function frame(time) {
    const dt = lastTime ? time - lastTime : 16;
    lastTime = time;

    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    const w = W(), h = H();

    // Heartbeat background pulse
    heartbeatPhase += 0.015;
    const pulse = Math.sin(heartbeatPhase) * 0.5 + 0.5;
    const bgBright = 8 + pulse * 6;
    ctx.fillStyle = `rgb(${bgBright}, ${bgBright}, ${bgBright + 4})`;
    ctx.fillRect(0, 0, w, h);

    // Twinkling stars
    drawStars(time);

    // Floating morphing shapes
    for (const s of shapes) {
      updateShape(s, time, dt);
      drawMorphedShape(s, time);
    }

    // === Bubbles ===
    // Spawn new bubbles periodically
    bubbleSpawnTimer += dt;
    if (bubbleSpawnTimer > 3000 && bubbles.length < MAX_BUBBLES) {
      bubbleSpawnTimer = 0;
      bubbles.push(createBubble());
    }

    // Update & draw bubbles
    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];

      if (b.popping) {
        b.popProgress += 0.04;
        if (b.popProgress >= 1) {
          bubbles.splice(i, 1);
          continue;
        }
        drawBubble(b, time);
        continue;
      }

      // Float upward
      b.y += b.vy;
      b.x += b.vx;

      // Remove if off screen top
      if (b.y < -b.size * 2) {
        bubbles.splice(i, 1);
        continue;
      }

      drawBubble(b, time);
    }

    // Glows
    for (let i = glows.length - 1; i >= 0; i--) {
      const g = glows[i];
      g.radius += 1.5; g.alpha -= 0.005;
      if (g.alpha <= 0 || g.radius >= g.maxRadius) { glows.splice(i, 1); continue; }
      ctx.save();
      const gradient = ctx.createRadialGradient(g.x, g.y, 0, g.x, g.y, g.radius);
      gradient.addColorStop(0, g.color); gradient.addColorStop(1, 'transparent');
      ctx.globalAlpha = g.alpha; ctx.fillStyle = gradient;
      ctx.beginPath(); ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }

    // Ripples
    for (let i = ripples.length - 1; i >= 0; i--) {
      const r = ripples[i];
      r.radius += 1.8; r.alpha -= 0.008;
      if (r.alpha <= 0 || r.radius >= r.maxRadius) { ripples.splice(i, 1); continue; }
      ctx.save(); ctx.globalAlpha = r.alpha; ctx.strokeStyle = r.color; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
    }

    // Bloom shapes
    for (let i = bloomShapes.length - 1; i >= 0; i--) {
      const b = bloomShapes[i];
      b.x += b.vx; b.y += b.vy; b.vx *= 0.99; b.vy *= 0.99;
      b.rotation += b.rotSpeed; b.life -= b.decay;
      if (b.life <= 0) { bloomShapes.splice(i, 1); continue; }
      drawSimpleShape({ ...b, alpha: b.life * b.alpha, size: b.size }, time);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.98; p.vy *= 0.98; p.vy += 0.02;
      p.life -= p.decay; p.rotation += p.rotSpeed;
      if (p.life <= 0) { particles.splice(i, 1); continue; }
      ctx.save(); ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
      if (p.type === 'circle') { ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill(); }
      else { drawStar(p.x, p.y, p.size * p.life, 5, p.rotation); ctx.fill(); }
      ctx.restore();
    }

    // Trail particles
    for (let i = trailParticles.length - 1; i >= 0; i--) {
      const tp = trailParticles[i];
      tp.x += tp.vx; tp.y += tp.vy; tp.life -= tp.decay;
      if (tp.life <= 0) { trailParticles.splice(i, 1); continue; }
      ctx.save(); ctx.globalAlpha = tp.life * 0.7;
      const gradient = ctx.createRadialGradient(tp.x, tp.y, 0, tp.x, tp.y, tp.size * tp.life);
      gradient.addColorStop(0, tp.color); gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath(); ctx.arc(tp.x, tp.y, tp.size * tp.life, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }

    // Update reactive face
    updateFace(dt);

    requestAnimationFrame(frame);
  }

  // Init and start
  resize();
  requestAnimationFrame(frame);

  // --- Fullscreen on first interaction (mobile) ---
  let hasRequestedFullscreen = false;
  document.addEventListener('click', () => {
    if (hasRequestedFullscreen) return;
    hasRequestedFullscreen = true;
    const el = document.documentElement;
    if (el.requestFullscreen) el.requestFullscreen().catch(() => {});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  }, { once: false });

})();
</script>
</body>
</html>
